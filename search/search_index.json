{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\u26a1\ufe0f Circuit","text":"<p>Circuit is used in production at Slack and ready for general use \ud83d\ude80. The API is considered unstable as we continue to iterate on it.</p>"},{"location":"#overview","title":"Overview","text":"<p>Circuit is a simple, lightweight, and extensible framework for building Kotlin applications that\u2019s Compose from the ground up.</p> <p>Compose Runtime vs. Compose UI</p> <p>Compose itself is essentially two libraries \u2013 Compose Compiler and Compose UI. Most folks usually think of Compose UI, but the compiler (and associated runtime) are actually not specific to UI at all and offer powerful state management APIs.</p> <p>Jake Wharton has an excellent post about this: https://jakewharton.com/a-jetpack-compose-by-any-other-name/</p> <p>It builds upon core principles we already know like Presenters and UDF, and adds native support in its framework for all the other requirements we set out for above. It\u2019s heavily influenced by Cash App\u2019s Broadway architecture (talked about at Droidcon NYC, also very derived from our conversations with them).</p> <p>Circuit\u2019s core components are its <code>Presenter</code> and <code>Ui</code> interfaces.</p> <ol> <li>A <code>Presenter</code> and a <code>Ui</code> cannot directly access each other. They can only communicate through state and event emissions.</li> <li>UIs are compose-first.</li> <li>Presenters are also compose-first. They do not emit Compose UI, but they do use the Compose runtime to manage and emit state.</li> <li>Both <code>Presenter</code> and <code>Ui</code> each have a single composable function.</li> <li>In most cases, Circuit automatically connects presenters and UIs.</li> <li><code>Presenter</code> and <code>Ui</code> are both generic types, with generics to define the <code>UiState</code> types they communicate with.</li> <li>They are keyed by <code>Screen</code>s. One runs a new <code>Presenter</code>/<code>Ui</code> pairing by requesting them with a given <code>Screen</code> that they understand.</li> </ol> <p>Screens</p> <p>The pairing of a <code>Presenter</code> and <code>Ui</code> for a given <code>Screen</code> key is what we semantically call a \u201cscreen\u201d.</p> <ul> <li>Your application is composed of \u201cscreens\u201d.</li> <li>A simple counter <code>Presenter</code> + <code>Ui</code> pairing would be a \u201ccounter screen\u201d.</li> <li>Nested presenter/UIs would be \u201cnested circuits\u201d or \u201csub screen\u201d.</li> <li>Composite presenter/UIs would be \u201ccomposite screen\u201d.</li> <li>etc etc.</li> </ul> <p>Circuit\u2019s repo (https://github.com/slackhq/circuit) is being actively developed in the open, which allows us to continue collaborating with external folks too. We have a trivial-but-not-too-trivial sample app that we have been developing in it to serve as a demo for a number of common patterns in Circuit use.</p>"},{"location":"#counter-example","title":"Counter Example","text":"<p>This is a very simple case of a Counter screen that displays the count and has buttons to increment and decrement.</p> <p></p> <p>There\u2019s some glue code missing from this example that\u2019s covered in the Code Gen section later.</p> <pre><code>@Parcelize\ndata object CounterScreen : Screen {\n  data class CounterState(\n    val count: Int,\n    val eventSink: (CounterEvent) -&gt; Unit,\n  ) : CircuitUiState\n  sealed interface CounterEvent : CircuitUiEvent {\n    data object Increment : CounterEvent\n    data object Decrement : CounterEvent\n  }\n}\n\n@CircuitInject(CounterScreen::class, AppScope::class)\n@Composable\nfun CounterPresenter(): CounterState {\n  var count by rememberSaveable { mutableStateOf(0) }\n\n  return CounterState(count) { event -&gt;\n    when (event) {\n      CounterEvent.Increment -&gt; count++\n      CounterEvent.Decrement -&gt; count--\n    }\n  }\n}\n\n@CircuitInject(CounterScreen::class, AppScope::class)\n@Composable\nfun Counter(state: CounterState) {\n  Box(Modifier.fillMaxSize()) {\n    Column(Modifier.align(Alignment.Center)) {\n      Text(\n        modifier = Modifier.align(CenterHorizontally),\n        text = \"Count: ${state.count}\",\n        style = MaterialTheme.typography.displayLarge\n      )\n      Spacer(modifier = Modifier.height(16.dp))\n      Button(\n        modifier = Modifier.align(CenterHorizontally),\n        onClick = { state.eventSink(CounterEvent.Increment) }\n      ) { Icon(rememberVectorPainter(Icons.Filled.Add), \"Increment\") }\n      Button(\n        modifier = Modifier.align(CenterHorizontally),\n        onClick = { state.eventSink(CounterEvent.Decrement) }\n      ) { Icon(rememberVectorPainter(Icons.Filled.Remove), \"Decrement\") }\n    }\n  }\n}\n</code></pre>"},{"location":"#license","title":"License","text":"<pre><code>Copyright 2022 Slack Technologies, LLC\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#0240","title":"0.24.0","text":"<p>2024-09-16</p> <ul> <li>New: Add code gen support for kotlin-inject + kotlin-inject-anvil. See the code gen docs for usage instructions. We\u2019ve also added a sample project.</li> <li>New: <code>presenterTestOf()</code> and <code>Presenter.test()</code> functions now return a new <code>CircuitReceiveTurbine</code> interface. This interface slightly but importantly modifies the behavior of <code>awaitItem()</code> by making it only emit changed items rather than every item. If you do want to assert the equivalent state is emitted across recompositions, you can use <code>awaitUnchanged()</code>.</li> <li>New: Promote <code>LocalBackStack</code> to public API.</li> <li>Behavior change: Due to the above-documented change to <code>awaitItem()</code>, you may need to update tests that previously assumed duplicate emissions.</li> <li>Update to Kotlin <code>2.0.20</code>.</li> <li>Change: Switch to stdlib\u2019s implementation of <code>Uuid</code>. This release now requires Kotlin <code>2.0.20</code> or later.</li> <li>Add sample test to demonstrate <code>rememberAnsweringNavigator</code> result handling.</li> <li>Update to kotlinx.coroutines <code>1.9.0</code>.</li> <li>Update to compose-bom <code>2024.09.01</code>.</li> <li>Update to kotlinx.collections.immutable <code>0.3.8</code>.</li> <li>Update to androidx.activity <code>1.9.2</code>.</li> <li>Update to androidx.lifecycle <code>2.8.5</code>.</li> <li>Update to kotlin <code>2.0.20</code>.</li> <li>Build against KSP <code>2.0.20-1.0.25</code>.</li> </ul>"},{"location":"changelog/#0231","title":"0.23.1","text":"<p>2024-07-30</p> <ul> <li>New: Promote <code>NoOpRetainedStateRegistry</code> to public API for use in testing and previews.</li> <li>New: Add <code>CircuitPreview</code> helper function for composable previews that contain Circuit content.</li> <li>Enhancement: When running under <code>LocalInspectionMode</code>, Circuit\u2019s default <code>onUnavailableContent</code> now shows a simpler non-intrusive placeholder UI instead.</li> <li>Enhancement: Support secondary injected constructors in code gen.</li> <li>Fix: Fix non-dismissable <code>BottomSheetOverlay</code> crash when invoking back-press.</li> <li>Update to Kotlin <code>2.0.10</code>.</li> <li>Update to androidx.annotation <code>1.8.2</code>.</li> <li>Build against KSP <code>2.0.10-1.0.24</code>.</li> </ul>"},{"location":"changelog/#0230","title":"0.23.0","text":"<p>2024-07-30</p> <ul> <li>New: Add macOS, windows, linux, tvOS, and watchOS targets to Circuit\u2019s runtime and retained artifacts.</li> <li>New: Add macOS targets to Circuit\u2019s UI, backstack, overlay, test, circuitx (except gesture nav), and foundation artifacts.</li> <li>Slightly optimize <code>pausableState</code> #1455.</li> <li>Change: <code>OverlayHost.showFullScreenOverlay</code> now returns the <code>PopResult?</code> that was popped by the screen.</li> <li>Change: Remove <code>backstack</code> dependency from <code>circuit-runtime</code>. It was unnecessary and also accidentally imposed Compose UI on the runtime/presenter artifacts.</li> <li>Change: Make <code>Overlay</code> a <code>fun interface</code>.</li> <li>Breaking Change: Change <code>OverlayEffect</code> to use a new <code>OverlayScope</code> API that implements both <code>CoroutineScope</code> and <code>OverlayHost</code>, making both contexts available in the lambda.</li> <li>Update KSP to <code>2.0.0-1.0.24</code>.</li> <li>Update androidx.activity to <code>1.9.1</code>.</li> <li>Update androidx.lifecycle to <code>2.8.4</code>.</li> <li>Update androidx.annotation to <code>1.8.1</code>.</li> <li>Update KotlinPoet <code>1.18.1</code>.</li> <li>Update Compose Multiplatform to <code>1.6.11</code>.</li> </ul> <p>Special thanks to @aschulz90 and @chrisbanes for contributing to this release!</p>"},{"location":"changelog/#0222","title":"0.22.2","text":"<p>2024-06-04</p> <ul> <li>Fix: Fix <code>pausableState</code> recomposition loops by avoiding backward snapshot writes.</li> <li>New: Add <code>Circuit.presentWithLifecycle</code> flag to enable/disable automatic <code>pausableState</code> use. This is enabled by default.</li> <li>Update Compose Multiplatform to <code>1.6.11</code>.</li> <li>Update androidx.lifecycle to <code>2.8.1</code>.</li> <li>Update androidx.appcompat to <code>1.7.0</code>.</li> </ul> <p>Special thanks to @chrisbanes, @adamp, and Chuck Jazdzewski for contributing to this release and helping us find a runtime fix for the <code>pausableState</code> issue!</p>"},{"location":"changelog/#0221","title":"0.22.1","text":"<p>2024-05-28</p> <ul> <li>Fix: Fix <code>rememberRetained</code> implicitly requiring <code>LocalContext</code> where it used to no-op.</li> <li>Update Molecule to <code>2.0.0</code>.</li> </ul>"},{"location":"changelog/#0220","title":"0.22.0","text":"<p>2024-05-28</p> <ul> <li>Update to Kotlin <code>2.0.0</code>.</li> <li>Update to KSP <code>2.0.0-1.0.21</code>.</li> <li>Update Compose Multiplatform to <code>1.6.10</code>.</li> <li>Switch to the compose compiler shipped with Kotlin.</li> </ul> <p>This release is otherwise identical to <code>0.21.0</code>, just updated to Kotlin 2.0.</p>"},{"location":"changelog/#0210","title":"0.21.0","text":"<p>2024-05-28</p> <ul> <li>New: Add WASM targets.</li> <li>New: Add <code>FakeNavigator</code> functions to check for the lack of pop/resetRoot events.</li> <li>New: Add <code>FakeNavigator</code> constructor param to add additional screens to the backstack.</li> <li>New: Add support for static UIs. In some cases, a UI may not need a presenter to compute or manage its state. Examples of this include UIs that are stateless or can derive their state from a single static input or an input [Screen]\u2019s properties. In these cases, make your screen implement the <code>StaticScreen</code> interface. When a <code>StaticScreen</code> is used, Circuit will internally allow the UI to run on its own and won\u2019t connect it to a presenter if no presenter is provided.</li> <li>New: Add <code>RecordLifecycle</code> and <code>LocalRecordLifecycle</code> composition local, allowing UIs and presenters to observe when they are \u2018active\u2019. Currently, a record is considered \u2018active\u2019 when it is the top record on the back stack.</li> <li>New: Add a <code>rememberRetainedSaveable</code> variant that participates in both <code>RetainedStateRegistry</code> and <code>SaveableStateRegistry</code> restoration, allowing layered state persistence.</li> <li>The logic is the following upon <code>rememberRetainedSaveable</code> entering composition:<ul> <li>consume from both <code>RetainedStateRegistry</code> and <code>SaveableStateRegistry</code>, if available</li> <li>if the retained value is available, use that</li> <li>otherwise, if the saveable restored value is available, use that</li> <li>otherwise, re-initialize the value</li> </ul> </li> <li>There is also an overload of <code>rememberRetained</code> that explicitly requires a <code>Saver</code> parameter.</li> <li>Behaviour Change: Presenters are now \u2018paused\u2019 when inactive and replay their last emitted <code>CircuitUiState</code> when they are not active. Presenters can opt-out of this behavior by implementing <code>NonPausablePresenter</code>.</li> <li>Behaviour Change: <code>NavigatorImpl.goTo</code> no longer navigates if the <code>Screen</code> is equal to <code>Navigator.peek()</code>.</li> <li>Behaviour Change: <code>Presenter.present</code> is now annotated with <code>@ComposableTarget(\"presenter\")</code>. This helps prevent use of Compose UI in the presentation logic as the compiler will emit a warning if you do. Note this does not appear in the IDE, so it\u2019s recommended to use <code>allWarningsAsErrors</code> to fail the build on this event.</li> <li>Behaviour Change: Guard against <code>Navigator.goTo()</code> calls to the same current screen.</li> <li>Change: <code>Navigator.goTo</code> now returns a Bool indicating navigation success.</li> <li>Change: Move iOS <code>GestureNavigationDecoration</code> impl to <code>commonMain</code> and rename to <code>CupertinoGestureNavigationDecoration</code>.</li> <li>Change: Target jvmTarget <code>1.8</code> in core libraries.</li> <li>Fix: Fix saveable state being restored when using reset root navigation events.</li> <li>Deprecation: <code>FakeNavigator.assertIsEmpty</code> and <code>expectNoEvents</code> (use the specific event type methods instead)</li> <li>Mark <code>Presenter.Factory</code> as <code>@Stable</code>.</li> <li>Mark <code>Ui.Factory</code> as <code>@Stable</code>.</li> <li>Mark <code>CircuitContext</code> as <code>@Stable</code>.</li> <li>Mark <code>EventListener</code> as <code>@Stable</code>.</li> <li>Mark <code>EventListener.Factory</code> as <code>@Stable</code>.</li> <li>[samples] Improve interop sample significantly.</li> <li>Update Kotlin to <code>1.9.24</code>.</li> <li>Update KSP to <code>1.9.24-2.0.20</code>.</li> <li>Update compose-compiler to <code>1.5.14</code>.</li> <li>Update KotlinPoet to <code>1.17.0</code>.</li> <li>Update androidx.lifecycle to <code>2.8.0</code>.</li> <li>Update Molecule to <code>1.4.3</code>.</li> <li>Update androidx.annotation to <code>1.8.0</code>.</li> <li>Update kotlinx.coroutines to <code>1.8.1</code>.</li> <li>Update Compose Multiplatform to <code>1.6.2</code>.</li> <li>Update Compose UI to <code>1.6.7</code>.</li> <li>Update Compose Runtime to <code>1.6.7</code>.</li> <li>Update Compose Animation to <code>1.6.7</code>.</li> <li>Update Compose Material to <code>1.6.7</code>.</li> <li>Update androidx.core to <code>1.13.1</code>.</li> <li>Update androidx.activity to <code>1.9.0</code>.</li> <li>Update dagger to <code>2.51.1</code>.</li> <li>Update uuid to <code>0.8.4</code>.</li> </ul> <p>Special thanks to @chrisbanes, @alexvanyo, @eboudrant, @edenman, and @JustinBis for contributing to this release!</p>"},{"location":"changelog/#0200","title":"0.20.0","text":"<p>2024-03-18</p> <ul> <li>New: Enable <code>RememberObserver</code> to work with <code>rememberRetained</code>.</li> <li>New: Add <code>Navigator.popRoot()</code>. extension (#1274)</li> <li>Behavior change: Add a key to <code>CircuitContent</code> to keep <code>Ui</code> and <code>Presenter</code> consistent. We already did this for presenters, this just makes it consistent for both.</li> <li>[circuitx-android] Implement <code>ToastEffect</code>.</li> <li>Fix: Fix <code>rememberImpressionNavigator()</code> not delegating <code>PopResult</code>.</li> <li>Fix: Navigator - Pass <code>PopResult</code> to <code>onRootPop()</code>.</li> <li>Fix: Check <code>canRetainCheck</code> when saving <code>RetainedStateRegistry</code>.</li> <li>Enhancement: Improve error messaging when using assisted inject.</li> <li>Force <code>com.google.guava:listenablefuture</code> to <code>1.0</code> to avoid conflicts with Guava.</li> <li>Update compose-compiler to <code>1.5.10.1</code>.</li> <li>Update coroutines to <code>1.8.0</code>.</li> <li>Update to Compose Multiplatform <code>1.6.1</code>.</li> <li>Update Android compose dependencies to <code>1.6.3</code>.</li> <li>Update molecule to <code>1.4.1</code>.</li> <li>Update dagger to <code>2.51</code>.</li> <li>Update turbine to <code>1.1.0</code>.</li> <li>Update uuid to <code>0.8.3</code>.</li> <li>Update kotlin to <code>1.9.23</code>.</li> <li>Update KSP to <code>1.9.23-1.0.19</code>.</li> </ul> <p>Special thanks to @chrisbanes, @aschulz90, and @alexvanyo for contributing to this release!</p>"},{"location":"changelog/#0191","title":"0.19.1","text":"<p>2024-02-12</p> <p>This is a small bug fix release focused <code>SaveableBackStack</code> consistency and <code>FakeNavigator</code> API improvements.</p> <ul> <li>Fix <code>FakeNavigator.awaitNextScreen()</code> not suspending.</li> <li>Fix <code>FakeNavigator.resetRoot()</code> not returning the actual popped screens.</li> <li>Make <code>Navigator.peekBackStack()</code> and <code>Navigator.resetRoot()</code> return <code>ImmutableList</code>.</li> <li>Make <code>BackStack.popUntil()</code> return the <code>ImmutableList</code> of the popped records.</li> <li>Support <code>FakeNavigator.peekBackStack()</code> return the <code>ImmutableList</code> of the popped records.</li> <li>Strongly pop events and resetRoot events in <code>FakeNavigator</code>. This should offer much more information about the events.</li> <li>Use a real <code>BackStack</code> instance in <code>FakeNavigator</code> + allow for specifying a user-provided instance.</li> <li>Require an initial root screen to construct <code>FakeNavigator</code> unless using a custom <code>BackStack</code>.</li> <li>Note this slightly changes semantics, as now the root screen will not be recorded as the first <code>goTo</code> event.</li> <li>Require an initial root screen (or list of screens) for <code>rememberSaveableBackStack()</code>.</li> <li>Expose a top-level non-composable <code>Navigator()</code> factory function.</li> </ul>"},{"location":"changelog/#0190","title":"0.19.0","text":"<p>2024-02-09</p>"},{"location":"changelog/#navigation-with-results","title":"Navigation with results","text":"<p>This release introduces support for inter-screen navigation results. This is useful for scenarios where you want to pass data back to the previous screen after a navigation event, such as when a user selects an item from a list and you want to pass the selected item back to the previous screen.</p> <pre><code>var photoUrl by remember { mutableStateOf&lt;String?&gt;(null) }\nval takePhotoNavigator = rememberAnsweringNavigator&lt;TakePhotoScreen.Result&gt;(navigator) { result -&gt;\n  photoUrl = result.url\n}\n\n// Elsewhere\ntakePhotoNavigator.goTo(TakePhotoScreen)\n\n// In TakePhotoScreen.kt\ndata object TakePhotoScreen : Screen {\n  @Parcelize\n  data class Result(val url: String) : PopResult\n}\n\nclass TakePhotoPresenter {\n  @Composable fun present(): State {\n    // ...\n    navigator.pop(result = TakePhotoScreen.Result(newFilters))\n  }\n}\n</code></pre> <p>See the new section in the navigation docs for more details, as well as updates to the Overlays docs that help explain when to use an <code>Overlay</code> vs navigating to a <code>Screen</code> with a result.</p>"},{"location":"changelog/#support-for-multiple-back-stacks","title":"Support for multiple back stacks","text":"<p>This release introduces support for saving/restoring navigation state on root resets (aka multi back stack). This is useful for scenarios where you want to reset the back stack to a new root but still want to retain the previous back stack\u2019s state, such as an app UI that has a persistent bottom navigation bar with different back stacks for each tab.</p> <p>This works by adding two new optional <code>saveState</code> and <code>restoreState</code> parameters to <code>Navigator.resetRoot()</code>.</p> <pre><code>navigator.resetRoot(HomeNavTab1, saveState = true, restoreState = true)\n// User navigates to a details screen\nnavigator.push(EntityDetails(id = foo))\n// Later, user clicks on a bottom navigation item\nnavigator.resetRoot(HomeNavTab2, saveState = true, restoreState = true)\n// Later, user switches back to the first navigation item\nnavigator.resetRoot(HomeNavTab1, saveState = true, restoreState = true)\n// The existing back stack is restored, and EntityDetails(id = foo) will be top of\n// the back stack\n</code></pre> <p>There are times when saving and restoring the back stack may not be appropriate, so use this feature only when it makes sense. A common example where it probably does not make sense is launching screens which define a UX flow which has a defined completion, such as onboarding.</p>"},{"location":"changelog/#new-tutorial","title":"New Tutorial!","text":"<p>On top of Circuit\u2019s existing docs, we\u2019ve added a new tutorial to help you get started with Circuit. It\u2019s a step-by-step guide that walks you through building a simple inbox app using Circuit, intended to serve as a sort of small code lab that one could do in 1-2 hours. Check it out here.</p>"},{"location":"changelog/#overlay-improvements","title":"Overlay Improvements","text":"<ul> <li>New: Promote <code>AlertDialogOverlay</code>, <code>BasicAlertDialogOverlay</code>, and <code>BasicDialogOverlay</code> to <code>circuitx-overlay</code>.</li> <li>New: Add <code>OverlayEffect</code> to <code>circuit-overlay</code>. This offers a simple composable effect to show an overlay and await a result.   <pre><code>OverlayEffect(state) { host -&gt;\n  val result = host.show(AlertDialogOverlay(...))\n  // Do something with the result\n}\n</code></pre></li> <li>Add <code>OverlayState</code> and <code>LocalOverlayState</code> to <code>circuit-overlay</code>. This allows you to check the current overlay state (<code>UNAVAILABLE</code>, <code>HIDDEN</code>, or <code>SHOWING</code>).</li> <li>Mark <code>OverlayHost</code> as <code>@ReadOnlyOverlayApi</code> to indicate that it\u2019s not intended for direct implementation by consumers.</li> <li>Mark <code>Overlay</code> as <code>@Stable</code>.</li> </ul>"},{"location":"changelog/#misc","title":"Misc","text":"<ul> <li>Make <code>NavEvent.screen</code> public.</li> <li>Change <code>Navigator.popUntil</code> to be exclusive.</li> <li>Add <code>Navigator.peek()</code> to peek the top screen of the back stack.</li> <li>Add <code>Navigator.peekBackStack()</code> to peek the top screen of the back stack.</li> <li>Align spelling of back stack parameters across all APIs to <code>backStack</code>.</li> <li>Refreshed iOS Counter sample using SPM and SKIE.</li> <li>Convert STAR sample to KMP. Starting with Android and Desktop.</li> <li>Fix baseline profiles packaging. Due to a bug in the baseline profile plugin, we were not packaging the baseline profiles in the artifacts. This is now fixed.</li> <li>Mark <code>BackStack.Record</code> as <code>@Stable</code>.</li> <li>Fix an infinite loop in the <code>onRootPop</code> of the Android <code>rememberCircuitNavigator</code>.</li> <li>Update the default decoration to better match the android 34 transitions.</li> <li>Update androidx.lifecycle to <code>2.7.0</code>.</li> <li>Update to compose multiplatform to <code>1.5.12</code>.</li> <li>Update to compose to <code>1.6.1</code>.</li> <li>Update to compose-bom to <code>2024.02.00</code>.</li> <li>Update compose-compiler to <code>1.5.9</code>.</li> <li>Update AtomicFu to <code>0.23.2</code>.</li> <li>Update Anvil to <code>2.4.9</code>.</li> <li>Update KotlinPoet to <code>1.16.0</code>.</li> <li>Compile against KSP <code>1.9.22-1.0.17</code>.</li> </ul> <p>Special thanks to @milis92, @ChrisBanes, and @vulpeszerda for contributing to this release!</p>"},{"location":"changelog/#0182","title":"0.18.2","text":"<p>2024-01-05</p> <ul> <li>Fix: Fix lifetime of <code>Record</code>s\u2019 <code>ViewModelStores</code>. This fully fixes #1065.</li> <li>Update Molecule to <code>1.3.2</code>.</li> <li>Update Jetbrains\u2019 compose-compiler to <code>1.5.7.1</code>.</li> </ul> <p>Special thanks to @dandc87 for contributing to this release!</p>"},{"location":"changelog/#0181","title":"0.18.1","text":"<p>2024-01-01</p> <ul> <li>Fix: Fix popped Record\u2019s <code>ProvidedValues</code> lifetime. See #1065 for more details.</li> <li>Fix: Fix <code>GestureNavDecoration</code> dropping saveable/retained state on back gestures. See #1089 for more details.</li> </ul> <p>Special thanks to @ChrisBanes and @dandc87 for contributing to this release!</p>"},{"location":"changelog/#0180","title":"0.18.0","text":"<p>2023-12-29</p> <ul> <li>New: Support animating an overlay out after returning a result with <code>AnimatedOverlay</code>.</li> <li>Fix: Fix dropping back stack retained state on Android Activity rotations.</li> <li>Enhancement: Add ability to customize <code>ModalBottomSheet</code> appearance in <code>BottomSheetOverlay</code>.</li> <li>Update Kotlin to <code>1.9.22</code>.</li> <li>Update KSP to <code>1.9.22-1.0.16</code>.</li> <li>Update Dagger to <code>2.50</code>.</li> <li>Update kotlinx-collections-immutable to <code>0.3.7</code>.</li> <li>Update AndroidX Activity to <code>1.8.2</code>.</li> </ul> <p>Special thanks to @ChrisBanes, @chriswiesner, and @BryanStern for contributing to this release!</p>"},{"location":"changelog/#0171","title":"0.17.1","text":"<p>2023-12-05</p> <ul> <li>Enhancement: Commonize <code>SaveableStateRegistryBackStackRecordLocalProvider</code> to be supported across all currently supported platforms.</li> <li>Fix: Fix <code>LocalBackStackRecordLocalProviders</code> always returning a new composition local.</li> <li>Update <code>androidx.compose.compiler:compiler</code> to <code>1.5.5</code></li> <li>Update KotlinPoet to <code>1.15.3</code></li> <li>Update Dagger to <code>2.49</code></li> </ul> <p>Special thanks to @alexvanyo for contributing to this release.</p>"},{"location":"changelog/#0170","title":"0.17.0","text":"<p>2023-11-28</p>"},{"location":"changelog/#new-circuitx-effects-artifact","title":"New: circuitx-effects artifact","text":"<p>The circuitx-effects artifact provides some effects for use with logging/analytics. These effects are typically used in Circuit presenters for tracking <code>impressions</code> and will run only once until forgotten based on the current circuit-retained strategy.</p> <pre><code>dependencies {\n  implementation(\"com.slack.circuit:circuitx-effects:&lt;version&gt;\")\n}\n</code></pre> <p>Docs: https://slackhq.github.io/circuit/circuitx/#effects</p>"},{"location":"changelog/#new-add-codegen-mode-to-support-both-anvil-and-hilt","title":"New: Add codegen mode to support both Anvil and Hilt","text":"<p>Circuit\u2019s code gen artifact now supports generating for Hilt projects. See the docs for usage instructions: https://slackhq.github.io/circuit/code-gen/</p>"},{"location":"changelog/#misc_1","title":"Misc","text":"<ul> <li>Decompose various <code>CircuitContent</code> internals like <code>rememberPresenter()</code>, <code>rememberUi</code>, etc for reuse.</li> <li>Make <code>CircuitContent()</code> overload that accepts a pre-constructed presenter/ui parameters public to allow for more control over content.</li> <li>[samples] Update README to include the interop sample.</li> <li>[samples] Various bugfixes to samples.</li> <li>[docs] Link sources in kdocs.</li> <li>[docs] Nest CircuitX artifacts in kdocs ToC.</li> <li>Update uuid to <code>0.8.2</code>.</li> <li>Update KotlinPoet to <code>1.15.1</code>.</li> <li>Update to Compose Multiplatform <code>1.5.11</code>.</li> <li>Update to Kotlin <code>1.9.21</code>.</li> <li>Update to KSP <code>1.9.21-1.0.15</code>.</li> <li>Update to compose-compiler (multiplatform) <code>1.5.4</code>.</li> <li>Update to Molecule <code>1.3.1</code>.</li> </ul> <p>Special thanks to @jamiesanson, @frett, and @bryanstern for contributing to this release!</p>"},{"location":"changelog/#0161","title":"0.16.1","text":"<p>2023-11-09</p> <ul> <li>Fix: Fix retained value not recalculating if inputs changed.</li> <li>Build against KSP <code>1.9.20-1.0.14</code>.</li> </ul>"},{"location":"changelog/#0160","title":"0.16.0","text":"<p>2023-11-01</p> <ul> <li>New: <code>circut-retained</code> is now enabled automatically in <code>CircuitCompositionLocals</code> by default, we still allowing overriding it with no-op implementation.</li> <li>Update to Kotlin <code>1.9.20</code>.</li> <li>Update Compose Multiplatform to <code>1.5.2</code>.</li> <li>Update <code>agp</code> to <code>8.1.2</code>.</li> <li>Update <code>androidx.activity</code> to <code>1.8.0</code>.</li> <li>Update <code>benchmark</code> to <code>1.2.0</code>.</li> <li>Update <code>coil</code> to <code>2.5.0</code>.</li> <li>Update <code>compose.material3</code> to <code>1.1.2</code>.</li> <li>Update <code>compose.material</code> to <code>1.5.4</code>.</li> <li>Update <code>compose.runtime</code> to <code>1.5.4</code>.</li> <li>Update <code>compose.ui</code> to <code>1.5.4</code>.</li> <li>Update <code>roborazzi</code> to <code>1.6.0</code>.</li> </ul>"},{"location":"changelog/#0150","title":"0.15.0","text":"<p>2023-09-20</p>"},{"location":"changelog/#new-allow-retained-state-to-be-retained-whilst-uis-and-presenters-are-on-the-back-stack","title":"New: Allow retained state to be retained whilst UIs and Presenters are on the back stack.","text":"<p>Originally, <code>circuit-retained</code> was implemented as a solution for preserving arbitrary data across configuration changes on Android. With this change it now also acts as a solution for retaining state across the back stack, meaning that traversing the backstack no longer causes restored contents to re-run through their empty states anymore.</p> <p>To support this, each back stack entry now has its own <code>RetainedStateRegistry</code> instance.</p> <p>Note that <code>circuit-retained</code> is still optional for now, but we are considering making it part of <code>CircuitCompositionLocals</code> in the future. Please let us know your thoughts in this issue: https://github.com/slackhq/circuit/issues/891.</p> <p>Full details + demos can be found in https://github.com/slackhq/circuit/pull/888. Big thank you to @chrisbanes for the implementation!</p>"},{"location":"changelog/#other-changes","title":"Other changes","text":"<ul> <li>New: Add <code>collectAsRetainedState</code> utility function, analogous to <code>collectAsState</code> but will retain the previous value across configuration changes and back stack entries.</li> <li>Enhancement: Optimize <code>rememberRetained</code> with a port of the analogous optimization in <code>rememberSaveable</code>. See #850.</li> <li>Enhancement: <code>Presenter</code> and <code>Ui</code> interfaces are now annotated as <code>@Stable</code>.</li> <li>Fix: Fix <code>GestureNavigationDecoration</code> function parameter order.</li> <li>Fix: <code>BackHandler</code> on iOS now has the proper file name.</li> <li>Fix: Key the <code>presenter.present()</code> in <code>CircuitContent</code> on the <code>Screen</code> rather than the <code>presenter</code> itself, which fixes a severe issue that prevented <code>currentCompositeKeyHash</code> from working correctly on <code>rememberRetained</code> and <code>rememberSaveable</code> uses.</li> <li>Update CM compiler to <code>1.5.2</code>.</li> <li>Update CM to <code>1.5.1</code>.</li> <li>Update <code>androidx.compose.animation</code> to <code>1.5.1</code>.</li> <li>Update <code>androidx.compose.foundation</code> to <code>1.5.1</code>.</li> <li>Update <code>androidx.compose.runtime</code> to <code>1.5.1</code>.</li> <li>Update <code>androidx.compose.material</code> to <code>1.5.1</code>.</li> <li>Update <code>androidx.lifecycle</code> to <code>2.6.2</code>.</li> <li>Update <code>androidx.annotation</code> to <code>1.7.0</code>.</li> </ul>"},{"location":"changelog/#0141","title":"0.14.1","text":"<p>2023-09-03</p> <ul> <li>New: Add <code>GestureNavigationDecoration</code> to <code>CircuitX</code> courtesy of @chrisbanes.</li> </ul> <p>This is a new <code>NavDecoration</code> that allows for gesture-based navigation, such as predictive back in Android 14 or drag gestures in iOS. See the docs for more details.</p> <pre><code>NavigableCircuitContent(\n  navigator = navigator,\n  backstack = backstack,\n  decoration = GestureNavigationDecoration(\n    // Pop the back stack once the user has gone 'back'\n    navigator::pop\n  )\n)\n</code></pre> <ul> <li>Fix embedded baseline profiles in published artifacts. Unfortunately GMDs used to generate these are quite finicky to run so these are sometimes tricky to regen each release.</li> </ul> <p>Special thanks to @chrisbanes and @alexvanyo for contributing to this release!</p>"},{"location":"changelog/#0140","title":"0.14.0","text":"<p>2023-08-30</p> <ul> <li>New: Circuit now supports JS targets!</li> <li>New: Introduce CircuitX artifacts. CircuitX is a suite of extension artifacts for Circuit. These artifacts are intended to be   batteries-included implementations of common use cases, such as out-of-the-box <code>Overlay</code> types or   Android navigation interop. See the docs for more details.</li> <li>Enhancement: Promote <code>Screen</code> to its own artifact. This is now under the <code>com.slack.circuit.runtime.screen.Screen</code> name.</li> <li>Enhancement: Use <code>Screen</code> directly in the <code>BackStack</code> in place of <code>route</code>.</li> <li>Enhancement: No longer require <code>SaveableBackStack</code> in <code>NavigableCircuitContent</code>, now any <code>BackStack</code> impl is supported.</li> <li>Enhancement: Make <code>CanRetainChecker</code> more customizable in <code>circuit-retained</code>.</li> <li>Enhancement: Pass the whole list of active records to <code>DecoratedContent</code>, allowing more complex handling of back gestures (predictive back in android, drag gestures in iOS, etc).</li> <li>Enhancement: Refactor out a <code>buildCircuitContentProviders()</code> in <code>NavigableCircuitContent</code>, which enables <code>movableContentOf</code> to work since it\u2019s reusing the same instance for records across changes.</li> <li>Fix: Fix duplicated <code>Modifier</code> for <code>DecoratedContent</code>.</li> <li>Fix: Fix new presenter instances of the same type not being recomposed. See #799 for more details.</li> <li>Fix: Export iOS targets for <code>circuit-test</code> artifact.</li> <li>Demonstrate back handling for Compose Multiplatform in Counter sample.</li> <li>Add <code>kotlinx.collections.immutable</code> to core APIs.</li> <li>Update to Compile SDK 34.</li> <li>Update to Compose Multiplatform <code>1.5.0</code>.</li> <li>Update androidx.compose.compiler to <code>1.5.3</code>.</li> <li>Update androidx.compose.ui to <code>1.5.0</code>.</li> <li>Update androidx.compose.material to <code>1.5.0</code>.</li> <li>Update androidx.compose.runtime to <code>1.5.0</code>.</li> <li>Update androidx.compose.foundation to <code>1.5.0</code>.</li> <li>Update uuid to <code>0.8.1</code>.</li> <li>Update Molecule to <code>1.2.0</code>.</li> <li>Update Kotlin to <code>1.9.10</code>.</li> <li>Update KSP to <code>1.9.10-1.0.13</code>.</li> </ul> <p>Thanks to @chrisbanes and @ashdavies for contributing to this release!</p>"},{"location":"changelog/#0130-beta01","title":"0.13.0-beta01","text":"<p>2023-08-17</p> <ul> <li>New: Circuit now supports JS targets!</li> <li>New: Introduce CircuitX artifacts. CircuitX is a suite of extension artifacts for Circuit. These artifacts are intended to be   batteries-included implementations of common use cases, such as out-of-the-box <code>Overlay</code> types or   Android navigation interop. See the docs for more details.</li> <li>Fix: Fix new presenter instances of the same type not being recomposed. See #799 for more details.</li> <li>Fix: Export iOS targets for <code>circuit-test</code> artifact.</li> <li>Update to Compile SDK 34.</li> <li>Update to Compose Multiplatform <code>1.5.0-beta02</code>.</li> <li>Update androidx.compose.ui to <code>1.5.0</code>.</li> <li>Update androidx.compose.material to <code>1.5.0</code>.</li> <li>Update androidx.compose.runtime to <code>1.5.0</code>.</li> <li>Update androidx.compose.foundation to <code>1.5.0</code>.</li> <li>Update Molecule to <code>1.2.0</code>.</li> <li>Update KSP to <code>1.9.0-1.0.13</code>.</li> </ul> <p>Note this release is a beta release due to the dependency on CM <code>1.5.0-beta02</code>.</p>"},{"location":"changelog/#0121","title":"0.12.1","text":"<p>2023-08-01</p> <ul> <li>Patch release with baseline profiles bundled in the Android artifacts again.</li> <li>Update to Anvil <code>2.4.7</code>.</li> </ul>"},{"location":"changelog/#0120","title":"0.12.0","text":"<p>2023-07-28</p> <ul> <li>[foundation] Rename <code>CircuitConfig</code> -&gt; <code>Circuit</code>. There is a source-compatible typealias for <code>CircuitConfig</code> left with a deprecation replacement to ease migration.</li> <li>[foundation] Rename <code>CircuitContext.config</code> -&gt; <code>CircuitContext.circuit</code>. The previous <code>CircuitContext.config</code> function is left with a deprecation replacement to ease migration.</li> <li>[test] Add new <code>TestEventSink</code> helper for testing event emissions in UI tests.</li> <li>[overlay] Add missing coroutines implementation dependency.</li> <li>Update to Kotlin <code>1.9.0</code>.</li> <li>Update to KSP <code>1.9.0-1.0.12</code>.</li> <li>Update to Compose Multiplatform <code>1.4.3</code>.</li> <li>Update to Coroutines <code>1.7.3</code>.</li> <li>Update to Compose compiler to <code>1.5.1</code> (androidx) and <code>1.5.0</code> (compose-multiplatform).</li> <li>Update uuid to <code>0.8.0</code>.</li> </ul>"},{"location":"changelog/#0110","title":"0.11.0","text":"<p>2023-07-20</p> <ul> <li>[runtime] Fix race condition in <code>EventListener.start()</code> callback.</li> <li>[code gen] Update to Dagger 2.47.</li> <li>[docs] No longer recommend or require extracting intermediate event sink variables. This is no longer an issue \ud83c\udf89.</li> <li>Update Molecule to <code>1.0.0</code>.</li> </ul> <p>Thanks to @bryanstern for contributing to this release!</p>"},{"location":"changelog/#0101","title":"0.10.1","text":"<p>2023-07-09</p> <ul> <li>[runtime] Make <code>CircuitContent</code> overload with <code>Navigator</code> public.</li> <li>[runtime] Remember <code>Presenter</code> and <code>Ui</code> in <code>CircuitContent</code>.</li> <li>[runtime] Fix kdoc typo in <code>RememberRetained</code> .</li> </ul> <p>Special thanks to @chrisbanes and @bryanstern for contributing to this release!</p>"},{"location":"changelog/#0100","title":"0.10.0","text":"<p>2023-06-30</p> <ul> <li>[runtime] Fix wrong compose-compiler used in iOS targets. Now we\u2019re using the compose-multiplatform fork.</li> <li>[runtime] Allow creation of multiple <code>RetainedStateRegistry</code> instances.</li> <li>[docs] Add clarifying links to Events docs.</li> <li>[samples] Add new image detail view in STAR sample.</li> <li>Update Molecule to <code>0.11.0</code>.</li> <li>Update AndroidX compose-compiler to <code>1.4.8</code>.</li> <li>Update compose-multiplatform to <code>1.4.1</code>.</li> <li>Update to coroutines <code>1.7.2</code>.</li> <li>Update to Turbine <code>1.0.0</code>.</li> <li>Update to Kotlin <code>1.8.22</code>.</li> </ul> <p>Special thanks to @bryanstern, @saket, and @chrisbanes for contributing to this release!</p>"},{"location":"changelog/#091","title":"0.9.1","text":"<p>2023-06-02</p> <ul> <li>[runtime] Promote <code>NavEvent</code> subtypes to public API.</li> <li>[runtime] Update <code>com.benasher44:uuid</code> to <code>0.7.1</code>.</li> <li>[code gen] Update Anvil to <code>2.4.6</code>.</li> </ul>"},{"location":"changelog/#090","title":"0.9.0","text":"<p>2023-05-26</p>"},{"location":"changelog/#preliminary-support-for-ios-targets","title":"Preliminary support for iOS targets","text":"<p>Following the announcement of Compose for iOS alpha, this release adds <code>ios()</code> and <code>iosSimulatorArm64()</code> targets for the Circuit core artifacts. Note that this support doesn\u2019t come with any extra APIs yet for iOS, just basic target support only. We\u2019re not super sure what direction we want to take with iOS, but encourage others to try it out and let us know what patterns you like. We have updated the Counter sample to include an iOS app target as well, using Circuit for the presentation layer only and SwiftUI for the UI.</p> <p>Note that circuit-codegen and circuit-codegen-annotations don\u2019t support these yet, as Anvil and Dagger only support JVM targets.</p> <p>More details can be found in the PR: https://github.com/slackhq/circuit/pull/583</p>"},{"location":"changelog/#misc_2","title":"Misc","text":"<ul> <li>Use new baseline profile plugin for generating baseline profiles.</li> <li>Misc sample app fixes and updates.</li> <li>Add window size class example to STAR sample.</li> <li>Switch to Roborazzi for screenshot test samples.</li> <li>Small documentation updates.</li> <li>Add bi-directional Flow/Circuit interop to interop sample.</li> </ul> <p>Note that we unintentionally used an experimental animation API for <code>NavigatorDefaults.DefaultDecotration</code>, which may cause R8 issues if you use a newer, experimental version of Compose animation. To avoid issues, copy the animation code and use your own copy compiled against the newest animation APIs. We\u2019ll fix this after Compose 1.5.0 is released.</p>"},{"location":"changelog/#dependency-updates","title":"Dependency updates","text":"<pre><code>androidx.activity -&gt; 1.7.2\ncompose -&gt; 1.4.3\ncompose-compiler -&gt; 1.4.7\ncoroutines -&gt; 1.7.1\nkotlin -&gt; 1.8.21\nkotlinpoet -&gt; 1.13.2\nturbine -&gt; 0.13.0\n</code></pre>"},{"location":"changelog/#080","title":"0.8.0","text":"<p>2023-04-06</p>"},{"location":"changelog/#core-split-up-core-artifacts","title":"[Core] Split up core artifacts.","text":"<ul> <li><code>circuit-runtime</code>: common runtime components like <code>Screen</code>, <code>Navigator</code>, etc.</li> <li><code>circuit-runtime-presenter</code>: the <code>Presenter</code> API, depends on <code>circuit-runtime</code>.</li> <li><code>circuit-runtime-ui</code>: the <code>Ui</code> API, depends on <code>circuit-runtime</code>.</li> <li><code>circuit-foundation</code>: the circuit foundational APIs like <code>CircuitConfig</code>, <code>CircuitContent</code>, etc. Depends on the first three.</li> </ul> <p>The goal in this is to allow more granular dependencies and easier building against subsets of the API. For example, this would allow a presenter implementation to easily live in a standalone module that doesn\u2019t depend on any UI dependencies. Vice versa for UI implementations.</p> <p>Where we think this could really shine is in multiplatform projects where Circuit\u2019s UI APIs may be more or less abstracted away in service of using native UI, like in iOS.</p>"},{"location":"changelog/#circuit-runtime-artifact","title":"<code>circuit-runtime</code> artifact","text":"Before After com.slack.circuit.CircuitContext com.slack.circuit.runtime.CircuitContext com.slack.circuit.CircuitUiState com.slack.circuit.runtime.CircuitUiState com.slack.circuit.CircuitUiEvent com.slack.circuit.runtime.CircuitUiEvent com.slack.circuit.Navigator com.slack.circuit.runtime.Navigator com.slack.circuit.Screen com.slack.circuit.runtime.Screen"},{"location":"changelog/#circuit-runtime-presenter-artifact","title":"<code>circuit-runtime-presenter</code> artifact","text":"Before After com.slack.circuit.Presenter com.slack.circuit.runtime.presenter.Presenter"},{"location":"changelog/#circuit-runtime-ui-artifact","title":"<code>circuit-runtime-ui</code> artifact","text":"Before After com.slack.circuit.Ui com.slack.circuit.runtime.presenter.Ui"},{"location":"changelog/#circuit-foundation-artifact","title":"<code>circuit-foundation</code> artifact","text":"Before After com.slack.circuit.CircuitCompositionLocals com.slack.circuit.foundation.CircuitCompositionLocals com.slack.circuit.CircuitConfig com.slack.circuit.foundation.CircuitConfig com.slack.circuit.CircuitContent com.slack.circuit.foundation.CircuitContent com.slack.circuit.EventListener com.slack.circuit.foundation.EventListener com.slack.circuit.NavEvent com.slack.circuit.foundation.NavEvent com.slack.circuit.onNavEvent com.slack.circuit.foundation.onNavEvent com.slack.circuit.NavigableCircuitContent com.slack.circuit.foundation.NavigableCircuitContent com.slack.circuit.NavigatorDefaults com.slack.circuit.foundation.NavigatorDefaults com.slack.circuit.rememberCircuitNavigator com.slack.circuit.foundation.rememberCircuitNavigator com.slack.circuit.push com.slack.circuit.foundation.push com.slack.circuit.screen com.slack.circuit.foundation.screen"},{"location":"changelog/#more-highlights","title":"More Highlights","text":"<ul> <li>[Core] Remove Android-specific <code>NavigableCircuitContent</code> and just use common one. Back handling still runs through <code>BackHandler</code>, but is now configured in <code>rememberCircuitNavigator</code>.</li> <li>[Core] Add <code>defaultNavDecoration</code> to <code>CircuitConfig</code> to allow for customizing the default <code>NavDecoration</code> used in <code>NavigableCircuitContent</code>.</li> <li>[Core] Mark <code>CircuitUiState</code> as <code>@Stable</code> instead of <code>@Immutable</code>.</li> <li>[Code gen] Capitalize generated class names when source is a presenter function.</li> <li>[Sample] New <code>:samples:tacos</code> order builder sample to demonstrate complex state management.</li> <li>[Sample] <code>NavigableCircuitContent</code> example in the desktop counter.</li> <li>[Dependencies] Update compose to <code>1.4.1</code>.</li> <li>[Dependencies] Update compose-compiler to <code>1.4.4</code>.</li> <li>[Dependencies] Update androidx.activity to <code>1.7.0</code>.</li> <li>[Dependencies] Update molecule to <code>0.7.1</code>.</li> </ul>"},{"location":"changelog/#070","title":"0.7.0","text":"<p>2023-02-10</p> <ul> <li>New: Multiplatform support for <code>NavigableCircuitContent</code>! Special thanks to @ashdavies for contributions to make this possible.</li> <li>Fix: <code>circuit-retained</code> minSdk is now 21 again. We accidentally bumped it to 28 when merging in its instrumentation tests.</li> <li>Enhancement: embedded baseline profiles are now embedded per-artifact instead of in the root <code>circuit-core</code> artifact.</li> <li>Enhancement: <code>circuit-retained</code> is now covered in embedded baseline profiles.</li> <li>[Code Gen] Update Dagger to <code>2.45</code>.</li> <li>[Code Gen] Update KSP to <code>1.8.10-1.0.9</code>.</li> <li>Update to compose-compiler <code>1.4.2</code>.</li> <li>Update to Kotlin <code>1.8.10</code>.</li> </ul>"},{"location":"changelog/#060","title":"0.6.0","text":"<p>2023-02-02</p> <p>Happy groundhog day!</p> <ul> <li>Breaking API change: <code>Ui.Content()</code> now contains a <code>Modifier</code> parameter.</li> </ul> <p>This allows you to pass modifiers on to UIs directly.</p> <pre><code> public interface Ui&lt;UiState : CircuitUiState&gt; {\n-  @Composable public fun Content(state: UiState)\n+  @Composable public fun Content(state: UiState, modifier: Modifier)\n }\n</code></pre> <ul> <li>New: Add <code>Navigator.resetRoot(Screen)</code> function to reset the backstack root with a new root screen. There is a corresponding <code>awaitResetRoot()</code> function added to <code>FakeNavigator</code>.</li> <li>New: Add <code>EventListener.start</code> callback function.</li> <li>New: Add Compose UI dependency to circuit-core (to support <code>Modifier</code> in the API).</li> <li>Fix: Fix <code>CircuitContext.putTag</code> generics.</li> <li>Fix: Fix KSP code gen artifact to just be a pure JVM artifact.</li> <li>Fix: <code>EventListener.onState</code>\u2019s type is now <code>CircuitUiState</code> instead of <code>Any</code>.</li> <li>Removed: <code>ScreenUi</code> is now removed and <code>Ui.Factory</code> simply returns <code>Ui</code> instances now.</li> <li> <p>API Change: <code>CircuitConfig.onUnavailableContent</code> is now no longer nullable. By default it displays a big ugly error text. If you want the previous behavior of erroring, replace it with a composable function that just throws an exception.</p> </li> <li> <p>Dependency updates <pre><code>Kotlin 1.8.0\nCompose-JB 1.3.0\nKSP 1.8.0-1.0.9\nCompose Runtime 1.3.3\nCompose UI 1.3.3\nCompose Animation 1.3.3\n</code></pre></p> </li> </ul>"},{"location":"changelog/#050","title":"0.5.0","text":"<p>2022-12-22</p> <ul> <li>Enhancement: Circuit no longer requires manual provisioning of its internal backing <code>ViewModel</code>s. This is now done automatically by the Circuit itself.</li> <li>Enhancement: <code>circuit-retained</code> is now fully optional and not included as a transitive dependency of circuit-core. If you want to use it, see its installation instructions in its README.</li> <li>Enhancement: Mark <code>Screen</code> as <code>@Immutable</code>.</li> <li>Breaking API Change: <code>LocalCircuitOwner</code> is now just <code>LocalCircuitConfig</code> to be more idiomatic.</li> <li>Breaking API Change: <code>LocalRetainedStateRegistryOwner</code> is now just <code>LocalRetainedStateRegistry</code> to be more idiomatic.</li> <li>Breaking API Change: <code>Continuity</code> is now <code>internal</code> and not publicly exposed since it no longer needs to be manually provided.</li> <li>Breaking API Change: <code>ViewModelBackStackRecordLocalProvider</code> is now <code>internal</code> and not publicly exposed since it no longer needs to be manually provided.</li> <li>Fix: Add missing license info to pom.</li> <li>Dependency updates   <pre><code>[versions]\nanvil = \"2.4.3\"\ncompose-jb = \"1.2.2\"\ncompose-animation = \"1.3.2\"\ncompose-compiler = \"1.3.2\"\ncompose-foundation = \"1.3.1\"\ncompose-material = \"1.3.1\"\ncompose-material3 = \"1.0.1\"\ncompose-runtime = \"1.3.2\"\ncompose-ui = \"1.3.2\"\nkotlin = \"1.7.22\"\n</code></pre></li> </ul>"},{"location":"changelog/#040","title":"0.4.0","text":"<p>2022-12-07</p> <ul> <li>Breaking API Change: <code>Presenter</code> and <code>Ui</code> factories\u2019 <code>create()</code> functions now offer a <code>CircuitContext</code> parameter in place of a <code>CircuitConfig</code> parameter. This class contains a <code>CircuitConfig</code>, a tagging API, and access to parent contexts. This allows for plumbing your own metadata through Circuit\u2019s internals such as tracing tools, logging, etc.</li> <li>Enhancement: New lifecycle functions added to <code>EventListener</code>.</li> <li><code>onBeforeCreatePresenter</code></li> <li><code>onAfterCreatePresenter</code></li> <li><code>onBeforeCreateUi</code></li> <li><code>onAfterCreateUi</code></li> <li><code>onUnavailableContent</code></li> <li><code>onStartPresent</code></li> <li><code>onDisposePresent</code></li> <li><code>onStartContent</code></li> <li><code>onDisposeContent</code></li> <li><code>dispose</code></li> <li>Update Compose to <code>1.3.1</code>.</li> <li>Update Compose (JB) to <code>1.2.1</code>.</li> <li>Update Molecule to <code>0.6.1</code>.</li> <li>Added a demo to the STAR sample that shows how to navigate to standard Android components (#275).</li> </ul>"},{"location":"changelog/#031","title":"0.3.1","text":"<p>2022-11-07</p> <ul> <li>Enhancement: Add back the <code>onRootPop()</code> parameter in <code>rememberCircuitNavigator()</code> but use <code>LocalOnBackPressedDispatcherOwner</code> for backpress handling by default.</li> </ul>"},{"location":"changelog/#030","title":"0.3.0","text":"<p>2022-11-01</p> <ul> <li>New: The Overlay API is now extracted to a separate, optional <code>circuit-overlay</code> artifact.</li> <li>New: The <code>circuit-core</code> artifact now packages in baseline profiles.</li> <li>Enhancement: Simplify backstack root pop handling. There is no more <code>onRootPop()</code> option in <code>rememberCircuitNavigator()</code>, instead you should install your own <code>BackHandler()</code> prior to rendering your circuit content to customize back behavior when the circuit <code>Navigator</code> is at root.</li> <li>Fix: <code>circuit-codegen-annotations</code> is now a multiplatform project and doesn\u2019t accidentally impose the compose-desktop dependency.</li> </ul> <p>We\u2019ve also updated a number of docs around code gen, overlays, and interop (including a new interop sample).</p>"},{"location":"changelog/#022","title":"0.2.2","text":"<p>2022-10-27</p> <ul> <li>Enhancement: Code gen now supports non-assisted constructor-injected types.</li> <li>Enhancement: Code gen checks that functions and classes are visible to generated factories.</li> </ul>"},{"location":"changelog/#021","title":"0.2.1","text":"<p>2022-10-27</p> <ul> <li>Fix: Code gen didn\u2019t properly handle instantiating simple class types.</li> </ul>"},{"location":"changelog/#020","title":"0.2.0","text":"<p>2022-10-26</p> <ul> <li> <p>New: Code gen artifact. This targets specifically using Dagger + Anvil and will generate <code>Presenter</code> and <code>Ui.Factory</code> implementations for you. See <code>CircuitInject</code> for more details.   <pre><code>ksp(\"com.slack.circuit:circuit-codegen:x.y.z\")\nimplementation(\"com.slack.circuit:circuit-codegen-annotations:x.y.z\")\n</code></pre></p> </li> <li> <p>New: There is now an <code>EventListener</code> API for instrumenting state changes for a given <code>Screen</code>. See its docs for more details.</p> </li> <li>Fix: Rework <code>rememberRetained</code> implementation and support for multiple variables. Previously it only worked with one variable.</li> <li>Fix: Clean up some unnecessary transitive dependencies in misc artifacts.</li> </ul> <p>Dependency updates</p> <pre><code>androidx.activity 1.6.1\nandroidx.compose 1.3.0\nMolecule 0.5.0\n</code></pre>"},{"location":"changelog/#012","title":"0.1.2","text":"<p>2022-10-12</p> <ul> <li>Update to compose-jb <code>1.2.0</code>.</li> <li>Update to Turbine <code>0.12.0</code>.</li> <li>Fix: Accidentally running molecule twice in <code>Presenter.test()</code>.</li> </ul>"},{"location":"changelog/#011","title":"0.1.1","text":"<p>2022-10-10</p> <ul> <li>Fix: Accidentally bundling more Compose UI dependencies than necessary.</li> </ul>"},{"location":"changelog/#010","title":"0.1.0","text":"<p>2022-10-10</p> <p>Initial release, see the docs: https://slackhq.github.io/circuit/.</p> <p>Note that this library is still under active development and not recommended for production use. We\u2019ll do a more formal announcement when that time comes!</p>"},{"location":"circuit-content/","title":"CircuitContent","text":"<p>The simplest entry point of a Circuit screen is the composable <code>CircuitContent</code> function. This function accepts a <code>Screen</code> and automatically finds and pairs corresponding <code>Presenter</code> and <code>Ui</code> instances to render in it.</p> <pre><code>CircuitCompositionLocals(circuit) {\n  CircuitContent(HomeScreen)\n}\n</code></pre> <p>This can be used for simple screens or as nested components of larger, more complex screens.</p>"},{"location":"circuitx/","title":"CircuitX","text":"<p>CircuitX is a suite of extension artifacts for Circuit. These artifacts are intended to be batteries-included implementations of common use cases, such as out-of-the-box <code>Overlay</code> types or Android navigation interop.</p> <p>These packages differ from Circuit\u2019s core artifacts in a few ways:</p> <ul> <li>Their APIs may change more frequently during Circuit\u2019s development.</li> <li>These artifacts won\u2019t ship with their own baseline profiles.</li> <li>These artifacts are under the <code>com.slack.circuitx</code> package prefix.</li> <li>These artifacts may be platform-specific where appropriate.</li> </ul>"},{"location":"circuitx/#android","title":"Android","text":"<p>The <code>circuitx-android</code> artifact contains Android-specific extensions for Circuit.</p> <pre><code>dependencies {\n  implementation(\"com.slack.circuit:circuitx-android:&lt;version&gt;\")\n}\n</code></pre>"},{"location":"circuitx/#navigation","title":"Navigation","text":"<p>It can be important for Circuit to be able to navigate to Android targets, such as other activities or custom tabs. To support this, decorate your existing <code>Navigator</code> instance with <code>rememberAndroidScreenAwareNavigator()</code>.</p> <pre><code>class MainActivity : Activity {\n  override fun onCreate(savedInstanceState: Bundle?) {\n    setContent {\n      val backStack = rememberSaveableBackStack(root = HomeScreen)\n      val navigator = rememberAndroidScreenAwareNavigator(\n        rememberCircuitNavigator(backstack), // Decorated navigator\n        this@MainActivity\n      )\n      CircuitCompositionLocals(circuit) {\n        NavigableCircuitContent(navigator, backstack)\n      }\n    }\n  }\n}\n</code></pre> <p><code>rememberAndroidScreenAwareNavigator()</code> has two overloads - one that accepts a <code>Context</code> and one that accepts an <code>AndroidScreenStarter</code>. The former is just a shorthand for the latter that only supports <code>IntentScreen</code>. You can also implement your own starter that supports other screen types.</p> <p><code>AndroidScreen</code> is the base <code>Screen</code> type that this navigator and <code>AndroidScreenStarter</code> interact with. There is a built-in <code>IntentScreen</code> implementation that wraps an <code>Intent</code> and an options <code>Bundle</code> to pass to <code>startActivity()</code>. Custom <code>AndroidScreens</code> can be implemented separately and route through here, but you should be sure to implement your own <code>AndroidScreenStarter</code> to handle them accordingly.</p>"},{"location":"circuitx/#effects","title":"Effects","text":"<p>CircuitX provides some effects for use with logging/analytics. These effects are typically used in Circuit presenters for tracking <code>impressions</code> and will run only once until forgotten based on the  current circuit-retained strategy.</p> <pre><code>dependencies {\n  implementation(\"com.slack.circuit:circuitx-effects:&lt;version&gt;\")\n}\n</code></pre>"},{"location":"circuitx/#impressioneffect","title":"ImpressionEffect","text":"<p><code>ImpressionEffect</code> is a simple single fire side effect useful for logging or analytics.  This <code>impression</code> will run only once until it is forgotten based on the current <code>RetainedStateRegistry</code>.</p> <pre><code>ImpressionEffect {\n  // Impression \n}\n</code></pre>"},{"location":"circuitx/#launchedimpressioneffect","title":"LaunchedImpressionEffect","text":"<p>This is useful for async single fire side effects like logging or analytics. This effect will run a  suspendable <code>impression</code> once until it is forgotten based on the <code>RetainedStateRegistry</code>.</p> <pre><code>LaunchedImpressionEffect {\n  // Impression \n}\n</code></pre>"},{"location":"circuitx/#rememberimpressionnavigator","title":"RememberImpressionNavigator","text":"<p>A <code>LaunchedImpressionEffect</code> that is useful for async single fire side effects like logging or analytics that need to be navigation aware. This will run the <code>impression</code> again if it re-enters the composition after a navigation event.</p> <pre><code>val navigator = rememberImpressionNavigator(\n  navigator = Navigator()\n) {\n  // Impression\n}\n</code></pre>"},{"location":"circuitx/#gesture-navigation","title":"Gesture Navigation","text":"<p>CircuitX provides <code>NavDecoration</code> implementation which support navigation through appropriate gestures on certain platforms.</p> <pre><code>dependencies {\n  implementation(\"com.slack.circuit:circuitx-gesture-navigation:&lt;version&gt;\")\n}\n</code></pre> <p>To enable gesture navigation support, you can use the use the <code>GestureNavigationDecoration</code>function:</p> <pre><code>NavigableCircuitContent(\n  navigator = navigator,\n  backStack = backstack,\n  decoration = GestureNavigationDecoration(\n    // Pop the back stack once the user has gone 'back'\n    navigator::pop\n  )\n)\n</code></pre>"},{"location":"circuitx/#android_1","title":"Android","text":"<p>On Android, this supports the Predictive back gesture which is available on Android 14 and later (API level 34+). On older platforms, Circuit\u2019s default <code>NavDecoration</code> decoration is used instead.</p> Star sample running on an Android 14 device"},{"location":"circuitx/#ios","title":"iOS","text":"<p>On iOS, this simulates iOS\u2019s \u2018Interactive Pop Gesture\u2019 in Compose UI, allowing the user to swipe Circuit UIs away. As this is a simulation of the native behavior, it does not match the native functionality perfectly. However, it is a good approximation.</p> Tivi app running on iPhone"},{"location":"circuitx/#other-platforms","title":"Other platforms","text":"<p>On other platforms we defer to Circuit\u2019s default <code>NavDecoration</code> decoration.</p>"},{"location":"circuitx/#overlays","title":"Overlays","text":"<p>CircuitX provides a few out-of-the-box <code>Overlay</code> implementations that you can use to build common UIs.</p> <pre><code>dependencies {\n  implementation(\"com.slack.circuit:circuitx-overlays:&lt;version&gt;\")\n}\n</code></pre>"},{"location":"circuitx/#bottomsheetoverlay","title":"<code>BottomSheetOverlay</code>","text":"<p><code>BottomSheetOverlay</code> is an overlay that shows a bottom sheet with a strongly-typed API for the input model to the sheet content and result type. This allows you to easily use a bottom sheet to prompt for user input and suspend the underlying Circuit content until that result is returned.</p> <pre><code>/** A hypothetical bottom sheet of available actions when long-pressing a list item. */\nsuspend fun OverlayHost.showLongPressActionsSheet(): Action {\n  return show(\n    BottomSheetOverlay(\n      model = listOfActions()\n    ) { actions, overlayNavigator -&gt;\n      ActionsSheet(\n        actions,\n        overlayNavigator::finish // Finish the overlay with the clicked Action\n      )\n    }\n  )\n}\n\n@Composable\nfun ActionsSheet(actions: List&lt;Action&gt;, onActionClicked: (Action) -&gt; Unit) {\n  Column {\n    actions.forEach { action -&gt;\n      TextButton(onClick = { onActionClicked(action) }) {\n        Text(action.title)\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"circuitx/#dialog-overlays","title":"Dialog Overlays","text":"<p><code>alertDialogOverlay</code> is function that returns an Overlay that shows a simple confirmation dialog with configurable inputs. This acts more or less as an <code>Overlay</code> shim over the Material 3 <code>AlertDialog</code> API.</p> <pre><code>/** A hypothetical confirmation dialog. */\nsuspend fun OverlayHost.showConfirmationDialog(): Action {\n  return show(\n    alertDialogOverlay(\n      titleText = { Text(\"Are you sure?\") },\n      confirmButton = { onClick -&gt; Button(onClick = onClick) { Text(\"Yes\") } },\n      dismissButton = { onClick -&gt; Button(onClick = onClick) { Text(\"No\") } },\n    )\n  )\n}\n</code></pre> <p>There are also more generic <code>BasicAlertDialog</code> and <code>BasicDialog</code> implementations that allow more customization.</p>"},{"location":"circuitx/#fullscreenoverlay","title":"<code>FullScreenOverlay</code>","text":"<p>Sometimes it\u2019s useful to have a full-screen overlay that can be used to show a screen in full above the current content. This API is fairly simple to use and just takes a <code>Screen</code> input of what content you want to show in the overlay.</p> <pre><code>overlayHost.showFullScreenOverlay(\n  ImageViewerScreen(id = url, url = url, placeholderKey = name)\n)\n</code></pre> <p>When to use <code>FullScreenOverlay</code> vs navigating to a <code>Screen</code>?</p> <p>While they achieve similar results, the key difference is that <code>FullScreenOverlay</code> is inherently an ephemeral UI that is controlled by an underlying primary UI. It cannot navigate elsewhere and it does not participate in the backstack.</p>"},{"location":"code-gen/","title":"Code Generation","text":"<p>Circuit offers a KSP-based code gen solution to ease boilerplate around generating factories for several dependency injection tools.</p>"},{"location":"code-gen/#installation","title":"Installation","text":"<pre><code>plugins {\n  id(\"com.google.devtools.ksp\")\n}\n\ndependencies {\n  api(\"com.slack.circuit:circuit-codegen-annotations:&lt;version&gt;\")\n  ksp(\"com.slack.circuit:circuit-codegen:&lt;version&gt;\")\n}\n</code></pre> <p>Currently supported types are: - Anvil and Anvil KSP - Dagger/Hilt - kotlin-inject + kotlin-inject-anvil</p> <p>Note that Dagger+Anvil is the default mode. </p> <p>If you are using another mode, you must specify the mode as a KSP arg.</p> <pre><code>ksp {\n  arg(\"circuit.codegen.mode\", \"hilt\") // or \"kotlin_inject_anvil\"\n}\n</code></pre> <p>If using Kotlin multiplatform with typealias annotations for Dagger annotations (i.e. expect  annotations in common with actual typealias declarations in JVM source sets), you can match on just  annotation short names alone to support this case via <code>circuit.codegen.lenient</code> mode.</p> <pre><code>ksp {\n  arg(\"circuit.codegen.lenient\", \"true\")\n}\n</code></pre> <p>If using anvil-ksp or kotlin-inject-anvil, you also need to indicate <code>@CircuitInject</code> as a  contributing annotation.</p> <pre><code>ksp {\n  // Anvil-KSP\n  arg(\"anvil-ksp-extraContributingAnnotations\", \"com.slack.circuit.codegen.annotations.CircuitInject\")\n  // kotlin-inject-anvil (requires 0.0.3+)\n  arg(\"kotlin-inject-anvil-contributing-annotations\", \"com.slack.circuit.codegen.annotations.CircuitInject\")\n}\n</code></pre>"},{"location":"code-gen/#usage","title":"Usage","text":"<p>The primary entry point is the <code>CircuitInject</code> annotation.</p> <p>This annotation is used to mark a UI or presenter class or function for code generation. When annotated, the type\u2019s corresponding factory will be generated and keyed with the defined <code>screen</code>.</p> <p>The generated factories are then contributed to Anvil via <code>ContributesMultibinding</code> and scoped with the provided <code>scope</code> key.</p>"},{"location":"code-gen/#classes","title":"Classes","text":"<p><code>Presenter</code> and <code>Ui</code> classes can be annotated and have their corresponding <code>Presenter.Factory</code> or <code>Ui.Factory</code> classes generated for them.</p> <p>Presenter <pre><code>@CircuitInject(HomeScreen::class, AppScope::class)\nclass HomePresenter @Inject constructor(...) : Presenter&lt;HomeState&gt; { ... }\n\n// Generates\n@ContributesMultibinding(AppScope::class)\nclass HomePresenterFactory @Inject constructor() : Presenter.Factory { ... }\n</code></pre></p> <p>UI <pre><code>@CircuitInject(HomeScreen::class, AppScope::class)\nclass HomeUi @Inject constructor(...) : Ui&lt;HomeState&gt; { ... }\n\n// Generates\n@ContributesMultibinding(AppScope::class)\nclass HomeUiFactory @Inject constructor() : Ui.Factory { ... }\n</code></pre></p>"},{"location":"code-gen/#functions","title":"Functions","text":"<p>Simple functions can be annotated and have a corresponding <code>Presenter.Factory</code> generated. This is primarily useful for simple cases where a class is just technical tedium.</p> <p>Requirements - Presenter function names must end in <code>Presenter</code>, otherwise they will be treated as UI functions. - Presenter functions must return a <code>CircuitUiState</code> type. - UI functions can optionally accept a <code>CircuitUiState</code> type as a parameter, but it is not required. - UI functions must return <code>Unit</code>. - Both presenter and UI functions must be <code>Composable</code>.</p> <p>Presenter <pre><code>@CircuitInject(HomeScreen::class, AppScope::class)\n@Composable\nfun HomePresenter(): HomeState { ... }\n\n// Generates\n@ContributesMultibinding(AppScope::class)\nclass HomePresenterFactory @Inject constructor() : Presenter.Factory { ... }\n</code></pre></p> <p>UI <pre><code>@CircuitInject(HomeScreen::class, AppScope::class)\n@Composable\nfun Home(state: HomeState) { ... }\n*\n// Generates\n@ContributesMultibinding(AppScope::class)\nclass HomeUiFactory @Inject constructor() : Ui.Factory { ... }\n</code></pre></p>"},{"location":"code-gen/#assisted-injection","title":"Assisted injection","text":"<p>Any type that is offered in <code>Presenter.Factory</code> and <code>Ui.Factory</code> can be offered as an assisted injection to types using Dagger <code>AssistedInject</code>. For these cases, the <code>AssistedFactory</code> -annotated interface should be annotated with <code>CircuitInject</code> instead of the enclosing class.</p> <p>Types available for assisted injection are:</p> <ul> <li><code>Screen</code> \u2013 the screen key used to create the <code>Presenter</code> or <code>Ui</code>.</li> <li><code>Navigator</code> \u2013 (presenters only)</li> <li><code>Circuit</code></li> </ul> <p>Each should only be defined at-most once.</p> <p>Examples <pre><code>// Function example\n@CircuitInject(HomeScreen::class, AppScope::class)\n@Composable\nfun HomePresenter(screen: Screen, navigator: Navigator): HomeState { ... }\n\n// Class example\nclass HomePresenter @AssistedInject constructor(\n  @Assisted screen: Screen,\n  @Assisted navigator: Navigator,\n  ...\n) : Presenter&lt;HomeState&gt; {\n  // ...\n  @CircuitInject(HomeScreen::class, AppScope::class)\n  @AssistedFactory\n  fun interface Factory {\n    fun create(screen: Screen, navigator: Navigator, context: CircuitContext): HomePresenter\n  }\n}\n</code></pre></p>"},{"location":"code-gen/#kotlin-inject","title":"kotlin-inject","text":"<p>Assisted injection in kotlin-inject works slightly differently for classes. Since there is no  <code>@AssistedFactory</code>, you can continue to just annotate the injected class directly.</p> <pre><code>@Inject\n@CircuitInject(HomeScreen::class, AppScope::class)\nclass HomePresenter(\n  @Assisted screen: Screen,\n  @Assisted navigator: Navigator,\n  ...\n) : Presenter&lt;HomeState&gt;\n</code></pre>"},{"location":"code-of-conduct/","title":"Code of Conduct","text":""},{"location":"code-of-conduct/#introduction","title":"Introduction","text":"<p>Diversity and inclusion make our community strong. We encourage participation from the most varied and diverse backgrounds possible and want to be very clear about where we stand.</p> <p>Our goal is to maintain a safe, helpful and friendly community for everyone, regardless of experience, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality, or other defining characteristic.</p> <p>This code and related procedures also apply to unacceptable behavior occurring outside the scope of community activities, in all community venues (online and in-person) as well as in all one-on-one communications, and anywhere such behavior has the potential to adversely affect the safety and well-being of community members.</p> <p>For more information on our code of conduct, please visit https://slackhq.github.io/code-of-conduct</p>"},{"location":"contributing/","title":"Contributors Guide","text":"<p>Note that this project is considered READ-ONLY. You are welcome to discuss or ask questions in the discussions section of the repo, but we do not normally accept external contributions without prior discussion.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>Check out this repo with Android Studio. It\u2019s a standard gradle project and conventional to checkout.</p> <p>Circuit is a Kotlin Multiplatform project, so ensure you have your environment set up  accordingly: https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-setup.html</p> <p>The primary project is <code>circuit</code>. The primary sample is <code>samples/star</code>.</p> <p>This project is written in Kotlin and should only use Kotlin.</p> <p>Code formatting is checked via Spotless. To run the formatter, use the <code>spotlessApply</code> command.</p> <pre><code>./gradlew spotlessApply\n</code></pre>"},{"location":"contributing/#ios","title":"iOS","text":"<p>To build any of the iOS checks, you must do the following: 1. Run <code>bundle install</code> to set up fastlane. 2. Have <code>swiftformat</code> installed. You can install it via <code>brew install swiftformat</code>.</p>"},{"location":"factories/","title":"Factories","text":"<p>At its core, Circuit works on the Factory pattern. Every <code>Presenter</code> and <code>Ui</code> is contributed to a <code>Circuit</code> instance by a corresponding factory that creates them for given <code>Screen</code>s. These are intended to be aggregated in the DI layer and added to a <code>Circuit</code> instance during construction.</p> <pre><code>val circuit = Circuit.Builder()\n  .addUiFactory(FavoritesUiFactory())\n  .addPresenterFactory(FavoritesPresenterFactory())\n  .build()\n</code></pre> <p>Look familiar?</p> <p>If you\u2019ve used Moshi or Retrofit, these should feel fairly familiar!</p> <p>Presenter factories can be generated or hand-written, depending on if they aggregate an entire screen or are simple one-offs. Presenters are also given access to the current Navigator in this level.</p> <pre><code>class FavoritesScreenPresenterFactory @Inject constructor(\n  private val favoritesPresenterFactory: FavoritesPresenter.Factory,\n) : Presenter.Factory {\n  override fun create(screen: Screen, navigator: Navigator, context: CircuitContext): Presenter&lt;*&gt;? {\n    return when (screen) {\n      is FavoritesScreen -&gt; favoritesPresenterFactory.create(screen, navigator, context)\n      else -&gt; null\n    }\n  }\n}\n</code></pre> <p>UI factories are similar, but generally should not aggregate other UIs unless there\u2019s a DI-specific reason to do so (which there usually isn\u2019t!).</p> <pre><code>class FavoritesScreenUiFactory @Inject constructor() : Ui.Factory {\n  override fun create(screen: Screen, context: CircuitContext): Ui&lt;*&gt;? {\n    return when (screen) {\n      is FavoritesScreen -&gt; favoritesUi()\n      else -&gt; null\n    }\n  }\n}\n\nprivate fun favoritesUi() = ui&lt;State&gt; { state, modifier -&gt; Favorites(state, modifier) }\n</code></pre> <p>Info</p> <p>Note how these include a <code>Modifier</code>. You should pass on these modifiers to your UI. Always provide a modifier!</p> <p>We canonically write these out as a separate function (<code>favoritesUi()</code>) that returns a <code>Ui</code>, which in turn calls through to the real (basic) Compose UI function (<code>Favorites()</code>). This ensures our basic compose functions are top-level and accessible by tests, and also discourages storing anything in class members rather than idiomatic composable state vars. If you use code gen, it handles the intermediate function for you.</p>"},{"location":"interop/","title":"Interop","text":"<p>Circuit can interop anywhere that Compose can interop. This includes common cases like Android  <code>Views</code>, RxJava, Kotlin <code>Flow</code>, and more.</p>"},{"location":"interop/#presenter","title":"<code>Presenter</code>","text":"<p>Lean on first-party interop-APIs where possible! See examples of interop with different libraries in the <code>:samples:interop</code> project.</p>"},{"location":"interop/#ui","title":"<code>UI</code>","text":""},{"location":"interop/#ui-view","title":"<code>Ui</code> -&gt; <code>View</code>","text":"<p>Just embed the Circuit in a <code>ComposeView</code> like any other Compose UI.</p>"},{"location":"interop/#view-ui","title":"<code>View</code> -&gt; <code>Ui</code>","text":"<p>You can wrap your view in an <code>AndroidView</code> in a custom <code>Ui</code> implementation. </p> <pre><code>class ExistingCustomViewUi : Ui&lt;State&gt; {\n  @Composable\n  fun Content(state: State, modifier: Modifier = Modifier) {\n    AndroidView(\n      modifier = ...\n      factory = { context -&gt;\n        ExistingCustomView(context)\n      },\n      update = { view -&gt;\n        view.setState(state)\n        view.setOnClickListener { state.eventSink(Event.Click) }\n      }\n  }\n}\n</code></pre>"},{"location":"navigation/","title":"Navigation","text":"<p>For navigable contents, we have a custom compose-based backstack implementation that the androidx folks shared with us. Navigation becomes two parts:</p> <ol> <li>A <code>BackStack</code>, where we use a <code>SaveableBackStack</code> implementation that saves a stack of <code>Screen</code>s and the <code>ProvidedValues</code> for each record on that stack (allowing us to save and restore on configuration changes automatically).</li> <li>A <code>Navigator</code>, which is a simple interface that we can point at a <code>BackStack</code> and offers simple <code>goTo(&lt;screen&gt;)</code>/<code>pop()</code> semantics. These are offered to presenters to perform navigation as needed to other screens.</li> </ol> <p>A new navigable content surface is handled via the <code>NavigableCircuitContent</code> functions.</p> <pre><code>setContent {\n  val backStack = rememberSaveableBackStack(root = HomeScreen)\n  val navigator = rememberCircuitNavigator(backStack)\n  NavigableCircuitContent(navigator, backStack)\n}\n</code></pre> <p>Warning</p> <p><code>SaveableBackStack</code> must have a size of 1 or more after initialization. It\u2019s an error to have a backstack with zero items.</p> <p>Presenters are then given access to these navigator instances via <code>Presenter.Factory</code> (described in Factories), which they can save if needed to perform navigation.</p> <pre><code>fun showAddFavorites() {\n  navigator.goTo(\n    AddFavorites(\n      externalId = uuidGenerator.generate()\n    )\n  )\n}\n</code></pre> <p>If you want to have custom behavior for when back is pressed on the root screen (i.e. <code>backstack.size == 1</code>), you should implement your own <code>BackHandler</code> and use it before creating the backstack.</p> <pre><code>setContent {\n  val backStack = rememberSaveableBackStack(root = HomeScreen)\n  BackHandler(onBack = { /* do something on root */ })\n  // The Navigator's internal BackHandler will take precedence until it is at the root screen.\n  val navigator = rememberCircuitNavigator(backstack)\n  NavigableCircuitContent(navigator, backstack)\n}\n</code></pre>"},{"location":"navigation/#results","title":"Results","text":"<p>In some cases, it makes sense for a screen to return a result to the previous screen. This is done by using the an answering Navigator pattern in Circuit.</p> <p>The primary entry point for requesting a result is the <code>rememberAnsweringNavigator</code> API, which takes a <code>Navigator</code> or <code>BackStack</code> and <code>PopResult</code> type and returns a navigator that can go to a screen and await a result.</p> <p>Result types must implement <code>PopResult</code> and are used to carry data back to the previous screen.</p> <p>The returned navigator should be used to navigate to the screen that will return the result. The target screen can then <code>pop</code> the result back to the previous screen and Circuit will automatically deliver this result to the previous screen\u2019s receiver.</p> <pre><code>var photoUri by remember { mutableStateOf&lt;String?&gt;(null) }\nval takePhotoNavigator = rememberAnsweringNavigator&lt;TakePhotoScreen.Result&gt;(navigator) { result -&gt;\n  photoUri = result.uri\n}\n\n// Elsewhere\ntakePhotoNavigator.goTo(TakePhotoScreen)\n\n// In TakePhotoScreen.kt\ndata object TakePhotoScreen : Screen {\n  @Parcelize\n  data class Result(val uri: String) : PopResult\n}\n\nclass TakePhotoPresenter {\n  @Composable fun present(): State {\n    // ...\n    navigator.pop(result = TakePhotoScreen.Result(photoUri))\n  }\n}\n</code></pre> <p>Circuit automatically manages saving/restoring result states and ensuring that results are only delivered to the original receiver that requested it. If the target screen does not pop back a result, the previous screen\u2019s receiver will just never receive one.</p> <p>When to use an <code>Overlay</code> vs navigating to a <code>Screen</code> with result?</p> <p>See this doc in Overlays!</p>"},{"location":"navigation/#nested-navigation","title":"Nested Navigation","text":"<p>Navigation carries special semantic value in <code>CircuitContent</code> as well, where it\u2019s common for UIs to want to curry navigation events emitted by nested UIs. For this case, there\u2019s a <code>CircuitContent</code> overload that accepts an optional onNavEvent callback that you must then forward to a Navigator instance.</p> <pre><code>@Composable fun ParentUi(state: ParentState, modifier: Modifier = Modifier) {\n  CircuitContent(NestedScreen, modifier = modifier, onNavEvent = { navEvent -&gt; state.eventSink(NestedNav(navEvent)) })\n}\n\n@Composable fun ParentPresenter(navigator: Navigator): ParentState {\n  return ParentState(...) { event -&gt;\n    when (event) {\n      is NestedNav -&gt; navigator.onNavEvent(event.navEvent)\n    }\n  }\n}\n\n@Composable \nfun NestedPresenter(navigator: Navigator): NestedState {\n  // These are forwarded up!\n  navigator.goTo(AnotherScreen)\n\n  // ...\n}\n</code></pre>"},{"location":"overlays/","title":"Overlays","text":"<p>The <code>circuit-overlay</code> artifact contains an optional API for presenting overlays on top of the current UI.</p> <pre><code>@Composable\nfun SubmitAnswer(state: FormState, modifier: Modifier = Modifier) {\n  if (state.promptConfirmation) {\n    OverlayEffect {\n      // Suspend on the result of the overlay\n      val result = show(ConfirmationDialogOverlay(title = \"Are you sure?\"))\n      state.eventSink(SubmitAnswerEvent(result))\n    }\n  }\n}\n</code></pre>"},{"location":"overlays/#usage","title":"Usage","text":"<p>The core APIs are the <code>Overlay</code> and <code>OverlayHost</code> interfaces.</p>"},{"location":"overlays/#overlay","title":"Overlay","text":"<p>An <code>Overlay</code> is composable content that can be shown on top of other content via an <code>OverlayHost</code>. Overlays are typically used for one-off request/result flows and should not usually attempt to do any sort of external navigation or make any assumptions about the state of the app. They should only emit a <code>Result</code> to the given <code>OverlayNavigator</code> parameter when they are done.</p> <pre><code>interface Overlay&lt;Result : Any&gt; {\n  @Composable\n  fun Content(navigator: OverlayNavigator&lt;Result&gt;)\n}\n</code></pre> <p>For common overlays, it\u2019s useful to create a common <code>Overlay</code> subtype that can be reused. For example: <code>BottomSheetOverlay</code>, <code>ModalOverlay</code>, <code>TooltipOverlay</code>, etc.</p>"},{"location":"overlays/#overlayhost","title":"OverlayHost","text":"<p>An <code>OverlayHost</code> is provided via composition local and exposes a <code>suspend show()</code> function to show an overlay and resume with a typed <code>Result</code>.</p> <pre><code>val result = LocalOverlayHost.current.show(BottomSheetOverlay(...))\n</code></pre> <p>Where <code>BottomSheetOverlay</code> is a custom bottom sheet implementation of an <code>Overlay</code>.</p> <p>In composition, you can also use <code>OverlayEffect</code> for a more streamlined API.</p> <pre><code>OverlayEffect {\n  val result = show(BottomSheetOverlay(...))\n}\n</code></pre>"},{"location":"overlays/#installation","title":"Installation","text":"<p>Add the dependency.</p> <pre><code>implementation(\"com.slack.circuit:circuit-overlay:$circuit_version\")\n</code></pre> <p>The simplest starting point for adding overlay support is the <code>ContentWithOverlays</code> composable function.</p> <pre><code>ContentWithOverlays {\n  // Your content here\n}\n</code></pre> <p>This will expose a <code>LocalOverlayHost</code> composition local that can be used by UIs to show overlays. This also exposes a <code>LocalOverlayState</code> composition local that can be used to check the current overlay state (<code>UNAVAILABLE</code>, <code>HIDDEN</code>, or <code>SHOWING</code>).</p>"},{"location":"overlays/#overlay-vs-popresult","title":"<code>Overlay</code> vs <code>PopResult</code>","text":"<p>Overlays and navigation results can accomplish similar goals, and you should choose the right one for your use case.</p> <code>Overlay</code> <code>PopResult</code> Survives process death \u274c \u2705 Type-safe \u2705 \ud83d\udfe1 Suspend on result \u2705 \u274c Participates in back stack \u274c \u2705 Supports non-saveable inputs/outputs \u2705 \u274c Can participate with the caller\u2019s UI \u2705 \u274c Can return multiple different result types \u274c \u2705 Works without a back stack \u2705 \u274c <p>*<code>PopResult</code> is technically type-safe, but it\u2019s not as strongly typed as <code>Overlay</code> results since there is nothing inherently requiring the target screen to pop a given result type back.</p>"},{"location":"presenter/","title":"Presenter","text":"<p>The core Presenter interface is this:</p> <pre><code>interface Presenter&lt;UiState : CircuitUiState&gt; {\n  @ComposableTarget(\"presenter\")\n  @Composable\n  fun present(): UiState\n}\n</code></pre> <p>Presenters are solely intended to be business logic for your UI and a translation layer in front of your data layers. They are generally Dagger-injected types as the data layers they interpret are usually coming from the DI graph. In simple cases, they can be typed as a simple <code>@Composable</code> presenter function allowing Circuit code gen to generate the corresponding interface and factory for you.</p> <p>A very simple presenter can look like this:</p> <pre><code>class FavoritesPresenter(...) : Presenter&lt;State&gt; {\n  @Composable override fun present(): State {\n    var favorites by remember { mutableStateOf(&lt;initial&gt;) }\n\n    return State(favorites) { event -&gt; ... }\n  }\n}\n</code></pre> <p>In this example, the <code>present()</code> function simply computes a <code>state</code> and returns it. If it has UI events to handle, an <code>eventSink: (Event) -&gt; Unit</code> property should be exposed in the <code>State</code> type it returns.</p> <p>With DI, the above example becomes something more like this:</p> <pre><code>class FavoritesPresenter @AssistedInject constructor(\n  @Assisted private val screen: FavoritesScreen,\n  @Assisted private val navigator: Navigator,\n  private val favoritesRepository: FavoritesRepository\n) : Presenter&lt;State&gt; {\n  @Composable override fun present(): State {\n    // ...\n  }\n  @AssistedFactory\n  fun interface Factory {\n    fun create(screen: FavoritesScreen, navigator: Navigator, context: CircuitContext): FavoritesPresenter\n  }\n}\n</code></pre> <p>Assisted injection allows passing on the <code>screen</code> and <code>navigator</code> from the relevant <code>Presenter.Factory</code> to this presenter for further reference.</p> <p>When dealing with nested presenters, a presenter could bypass implementing a class entirely by simply being written as a function that other presenters can use. </p> <pre><code>// From cashapp/molecule's README examples\n@Composable\nfun ProfilePresenter(\n  userFlow: Flow&lt;User&gt;,\n  balanceFlow: Flow&lt;Long&gt;,\n): ProfileModel {\n  val user by userFlow.collectAsState(null)\n  val balance by balanceFlow.collectAsState(0L)\n\n  return if (user == null) {\n    Loading\n  } else {\n    Data(user.name, balance)\n  }\n}\n</code></pre> <p>Presenters can present other presenters by injecting their assisted factories/providers, but note that this makes them a composite presenter that is now assuming responsibility for managing state of multiple nested presenters.</p>"},{"location":"presenter/#no-compose-ui","title":"No Compose UI","text":"<p>Presenter logic should not emit any Compose UI. They are purely for presentation business logic. To help enforce this, <code>Presenter.present</code> is annotated with <code>@ComposableTarget(\"presenter\")</code>. This helps prevent use of Compose UI in the presentation logic as the compiler will emit a warning if you do.</p> <p>Tip</p> <p>This warning does not appear in the IDE, so it\u2019s recommended to use <code>allWarningsAsErrors</code> in your build configuration to fail the build on this event. <pre><code>// In build.gradle.kts\nkotlin.compilerOptions.allWarningsAsErrors.set(true)\n</code></pre></p>"},{"location":"presenter/#retention","title":"Retention","text":"<p>There are three types of composable retention functions used in Circuit.</p> <ol> <li><code>remember</code> \u2013 from Compose, remembers a value across recompositions. Can be any type.</li> <li><code>rememberRetained</code> \u2013 custom, remembers a value across recompositions, the back stack, and configuration changes. Can be any type, but should not retain leak-able things like <code>Navigator</code> instances or <code>Context</code> instances. Backed by a hidden <code>ViewModel</code> on Android.</li> <li><code>rememberSaveable</code> \u2013 from Compose, remembers a value across recompositions, the back stack, configuration changes, and process death. Must be a primitive, <code>Parcelable</code> (on Android), or implement a custom <code>Saver</code>. This should not retain leakable things like <code>Navigator</code> instances or <code>Context</code> instances and is backed by the framework saved instance state system.</li> </ol> <p>Developers should use the right tool accordingly depending on their use case. Consider these three examples.</p> <p>The first one will preserve the <code>count</code> value across recompositions, but not the back stack, configuration changes, or process death.</p> <pre><code>@Composable\nfun CounterPresenter(): CounterState {\n  var count by remember { mutableStateOf(0) }\n\n  return CounterState(count) { event -&gt;\n    when (event) {\n      is CounterEvent.Increment -&gt; count++\n      is CounterEvent.Decrement -&gt; count--\n    }\n  }\n}\n</code></pre> <p>The second one will preserve the state across recompositions, the back stack, and configuration changes, but not process death.</p> <pre><code>@Composable\nfun CounterPresenter(): CounterState {\n  var count by rememberRetained { mutableStateOf(0) }\n\n  return CounterState(count) { event -&gt;\n    when (event) {\n      is CounterEvent.Increment -&gt; count++\n      is CounterEvent.Decrement -&gt; count--\n    }\n  }\n}\n</code></pre> <p>The third case will preserve the <code>count</code> state across recompositions, the back stack, configuration changes, and process death.</p> <pre><code>@Composable\nfun CounterPresenter(): CounterState {\n  var count by rememberSaveable { mutableStateOf(0) }\n\n  return CounterState(count) { event -&gt;\n    when (event) {\n      is CounterEvent.Increment -&gt; count++\n      is CounterEvent.Decrement -&gt; count--\n    }\n  }\n}\n</code></pre> <code>remember</code> <code>rememberRetained</code> <code>rememberSaveable</code> Recompositions \u2705 \u2705 \u2705 Back stack \u274c \u2705* \u2705* Configuration changes (Android) \u274c \u2705 \u2705 Process death \u274c \u274c \u2705 Can be non-Saveable types \u2705 \u2705 \u274c <p>*If using <code>NavigableCircuitContent</code>\u2019s default configuration.</p>"},{"location":"screen/","title":"Screen","text":"<p>Screens are keys for Presenter and UI pairings.</p> <p>The core <code>Screen</code> interface is this:</p> <pre><code>interface Screen : Parcelable\n</code></pre> <p>These types are <code>Parcelable</code> on Android for saveability in our backstack and easy deeplinking. A  <code>Screen</code> can be a simple marker <code>data object</code> or a <code>data class</code> with information to pass on.</p> <pre><code>@Parcelize\ndata object HomeScreen : Screen\n\n@Parcelize\ndata class AddFavoritesScreen(val externalId: UUID) : Screen\n</code></pre> <p>These are used by <code>Navigator</code>s (when called from presenters) or <code>CircuitContent</code> (when called from UIs) to start a new sub-circuit or nested circuit.</p> <pre><code>// In a presenter class\nfun showAddFavorites() {\n  navigator.goTo(\n    AddFavoritesScreen(\n      externalId = uuidGenerator.generate()\n    )\n  )\n}\n</code></pre> <p>The information passed into a screen can also be used to interact with the data layer. In the example here, we are getting the <code>externalId</code> from the screen in order to get information back from our repository. </p> <pre><code>// In a presenter class\nclass AddFavoritesPresenter\n@AssistedInject\nconstructor(\n  @Assisted private val screen: AddFavoritesScreen,\n  private val favoritesRepository: FavoritesRepository,\n) : Presenter&lt;AddFavoritesScreen.State&gt; {\n  @Composable\n  override fun present() : AddFavoritesScreen.State {\n      val favorite = favoritesRepository.getFavorite(screen.externalId)\n      // ...\n  }\n}\n</code></pre> <p>Screens are also used to look up those corresponding components in <code>Circuit</code>.</p> <pre><code>val presenter: Presenter&lt;*&gt;? = circuit.presenter(addFavoritesScreen, navigator)\nval ui: Ui&lt;*&gt;? = circuit.ui(addFavoritesScreen)\n</code></pre> <p>Nomenclature</p> <p>Semantically, in this example we would call all of these components together the \u201cAddFavorites Screen\u201d.</p>"},{"location":"setup/","title":"Setting up Circuit","text":"<p>Setting up Circuit is a breeze! Just add the following to your build:</p>"},{"location":"setup/#installation","title":"Installation","text":"<p>The simplest way to get up and running is with the <code>circuit-foundation</code> dependency, which includes all the core Circuit artifacts.</p> <pre><code>dependencies {\n  implementation(\"com.slack.circuit:circuit-foundation:&lt;version&gt;\")\n}\n</code></pre>"},{"location":"setup/#setup","title":"Setup","text":"<p>Create a <code>Circuit</code> instance. This controls all your common configuration, Presenter/Ui factories, etc.</p> <pre><code>val circuit = Circuit.Builder()\n  .addUiFactory(AddFavoritesUiFactory())\n  .addPresenterFactory(AddFavoritesPresenterFactory())\n  .build()\n</code></pre> <p>This configuration can be rebuilt via <code>newBuilder()</code> and usually would live in your program\u2019s DI graph.</p> <p>Once you have a configuration ready, the simplest way to get going with Circuit is via <code>CircuitCompositionLocals</code>. This automatically exposes the config to all child Circuit composables and allows you to get off the ground quickly with <code>CircuitContent</code>, <code>NavigableCircuitContent</code>, etc.</p> <pre><code>CircuitCompositionLocals(circuit) {\n  CircuitContent(AddFavoritesScreen())\n}\n</code></pre> <p>See the docs for <code>CircuitContent</code> and <code>NavigableCircuitContent</code> for more information.</p>"},{"location":"setup/#granular-artifacts","title":"Granular Artifacts","text":"<p>Circuit is split into a few different artifacts to allow for more granular control over your dependencies. The following table shows the available artifacts and their purpose:</p> Artifact ID Dependencies <code>circuit-backstack</code> Circuit\u2019s backstack implementation. <code>circuit-runtime</code> Common runtime components like <code>Screen</code>, <code>Navigator</code>, etc. <code>circuit-runtime-presenter</code> The <code>Presenter</code> API, depends on <code>circuit-runtime</code>. <code>circuit-runtime-ui</code> The <code>Ui</code> API, depends on <code>circuit-runtime</code>. <code>circuit-foundation</code> The Circuit foundational APIs like <code>Circuit</code>, <code>CircuitContent</code>, etc. Depends on the first three. <code>circuit-test</code> First-party test APIs for testing navigation, state emissions, and event sinks. <code>circuit-overlay</code> Optional <code>Overlay</code> APIs. <code>circuit-retained</code> Optional <code>rememberRetained()</code> APIs."},{"location":"setup/#platform-support","title":"Platform Support","text":"<p>Circuit is a multiplatform library, but not all features are available on all platforms. The following table shows which features are available on which platforms:</p> <ul> <li>\u2705 Available</li> <li>\u274c Not available</li> <li>\u2013 Not applicable</li> </ul> Feature Android JVM iOS JS Notes <code>Backstack</code> \u2705 \u2705 \u2705 \u2705 <code>CircuitContent</code> \u2705 \u2705 \u2705 \u2705 <code>ContentWithOverlays</code> \u2705 \u2705 \u2705 \u2705 <code>NavigableCircuitContent</code> \u2705 \u2705 \u2705 \u2705 <code>Navigator</code> \u2705 \u2705 \u2705 \u2705 <code>SaveableBackstack</code> \u2705 \u2705 \u2705 \u2705 Saveable is a no-op on non-android. <code>rememberCircuitNavigator</code> \u2705 \u2705 \u2705 \u2705 <code>rememberRetained</code> \u2705 \u2705 \u2705 \u2705 <code>TestEventSink</code> \u2705 \u2705 \u2705 \u2705 On JS you must use <code>asEventSinkFunction()</code>."},{"location":"states-and-events/","title":"States and Events","text":"<p>The core state and event interfaces in Circuit are <code>CircuitUiState</code> and <code>CircuitUiEvent</code>. All state and event types should implement/extend these marker interfaces.</p> <p>Presenters are simple functions that determine and return composable states. UIs are simple functions that render states. Uis can emit events via <code>eventSink</code> properties in state classes, which presenters then handle. These are the core building blocks!</p> <p>States should be <code>@Stable</code>; events should be <code>@Immutable</code>.</p> <p>Wait, event callbacks in state types?</p> <p>Yep! This may feel like a departure from how you\u2019ve written UDF patterns in the past, but we really like it. We tried different patterns before with event <code>Flow</code>s and having Circuit internals manage these for you, but we found they came with tradeoffs and friction points that we could avoid by just treating event emissions as another aspect of state. The end result is a tidier structure of state + event flows.</p> <ul> <li>Simpler cognitive overheads due to not always using <code>Flow</code> for events, which comes with caveats in compose (wrapping operators in <code>remember</code> calls, pipelining nested event flows, etc)</li> <li>Simple event-less UIs \u2013 state just doesn\u2019t have an event sink.</li> <li>Simpler testing \u2013 no manual event flow needed. You end up writing more realistic tests where you tick along your presenter by emitting with its returned states directly.</li> <li>Different state types can have different event handling (e.g. <code>Click</code> may not make sense for <code>Loading</code> states).</li> <li>No internal ceremony around setting up a <code>Channel</code> and multicasting event streams.</li> <li>No risk of dropping events (unlike <code>Flow</code>).</li> </ul> <p>Note</p> <p>Currently, while functions are treated as implicitly <code>Stable</code> by the compose compiler, they\u2019re not skippable when they\u2019re non-composable Unit-returning lambdas with equal-but-unstable captures. This may change though, and would be another free benefit for this case.</p> <p>A longer-form writeup can be found in this PR.</p>"},{"location":"testing/","title":"Testing","text":"<p>Circuit is designed to make testing as easy as possible. Its core components are not mockable nor do they need to be mocked. Fakes are provided where needed, everything else can be used directly.</p> <p>Circuit offers a test artifact containing APIs to aid testing both presenters and composable UIs:</p> <ul> <li><code>presenterTestOf()</code> - a top-level function that wraps a composable function to bridge the Compose and coroutines world. Use of this function is recommended for testing presenter state emissions and incoming UI events. Under the hood it leverages Molecule and Turbine. It returns a <code>CircuitReceiveTurbine</code>, a custom implementation of <code>ReceiveTurbine</code> that modifies the behavior of <code>awaitItem()</code> to only emit changed items (i.e. \u201cdistinct until changed\u201d).</li> <li><code>Presenter.test()</code> - an extension function on <code>Presenter</code> that bridges to <code>presenterTestOf()</code>.</li> <li><code>FakeNavigator</code> - a test fake implementing the <code>Navigator</code> interface. Use of this object is recommended when testing screen navigation (ie. goTo, pop/back). This acts as a real navigator and exposes recorded information for testing purposes.</li> <li><code>TestEventSink</code> - a generic test fake for recording and asserting event emissions through an event sink function.</li> </ul>"},{"location":"testing/#installation","title":"Installation","text":"<p>Test helpers are available via the <code>circuit-test</code> artifact.</p> <pre><code>testImplementation(\"com.slack.circuit:circuit-test:&lt;version&gt;\")\n</code></pre> <p>For Gradle JVM projects, you can use Gradle test fixtures syntax on the core circuit artifact.</p> <pre><code>testImplementation(testFixtures(\"com.slack.circuit:circuit:&lt;version&gt;\"))\n</code></pre>"},{"location":"testing/#example","title":"Example","text":"<p>Testing a Circuit Presenter and UI is a breeze! Consider the following example:</p> <pre><code>data class Favorite(id: Long, ...)\n\n@Parcelable\ndata object FavoritesScreen : Screen {\n  sealed interface State : CircuitUiState {\n    data object Loading : State\n    data object NoFavorites : State\n    data class Results(\n      val list: List&lt;Favorite&gt;,\n      val eventSink: (Event) -&gt; Unit\n    ) : State\n  }\n\n  sealed interface Event : CircuitUiEvent {\n    data class ClickFavorite(id: Long): Event\n  }\n}\n\nclass FavoritesPresenter @Inject constructor(\n    navigator: Navigator,\n    repo: FavoritesRepository\n) : Presenter&lt;State&gt; {\n  @Composable override fun present(): State {\n    val favorites by produceState&lt;List&lt;Favorites&gt;?&gt;(null) {\n      value = repo.getFavorites()\n    }\n\n    return when {\n      favorites == null -&gt; Loading\n      favorites.isEmpty() -&gt; NoFavorites\n      else -&gt;\n        Results(favorites) { event -&gt;\n          when (event) {\n            is ClickFavorite -&gt; navigator.goTo(FavoriteScreen(event.id))\n          }\n        }\n    }\n  }\n}\n\n@Composable\nfun FavoritesList(state: FavoritesScreen.State) {\n  when (state) {\n    Loading -&gt; Text(text = stringResource(R.string.loading_favorites))\n    NoFavorites -&gt; Text(\n      modifier = Modifier.testTag(\"no favorites\"),\n      text = stringResource(R.string.no_favorites)\n    )\n    is Results -&gt; {\n      Text(text = \"Your Favorites\")\n      LazyColumn {\n        items(state.list) { Favorite(it, state.eventSink) }\n      }\n    }\n  }\n}\n\n@Composable\nprivate fun Favorite(favorite: Favorite, eventSink: (FavoritesScreen.Event) -&gt; Unit) {\n  Row(\n    modifier = Modifier.testTag(\"favorite\"),\n    onClick = { eventSink(ClickFavorite(favorite.id)) }\n  ) {\n    Image(\n      drawable = favorite.drawable, \n      contentDescription = stringResource(R.string.favorite_image_desc)\n    )\n    Text(text = favorite.name)\n    Text(text = favorite.date)\n  }\n}\n</code></pre>"},{"location":"testing/#presenter-unit-tests","title":"Presenter Unit Tests","text":"<p>Here\u2019s a test to verify presenter emissions using the <code>Presenter.test()</code> helper. This function acts as a shorthand over Molecule + Turbine to give you a <code>ReceiveTurbine.() -&gt; Unit</code> lambda.</p> <pre><code>@Test \nfun `present - emit loading state then list of favorites`() = runTest {\n  val favorites = listOf(Favorite(1L, ...))\n\n  val repo = TestFavoritesRepository(favorites)\n  val presenter = FavoritesPresenter(navigator, repo)\n\n  presenter.test {\n    assertThat(awaitItem()).isEqualTo(FavoritesScreen.State.Loading)\n    val resultsItem = awaitItem() as Results\n    assertThat(resultsItem.favorites).isEqualTo(favorites)\n  }\n}\n</code></pre> <p>The same helper can be used when testing how the presenter responds to incoming events: </p> <pre><code>@Test \nfun `present - navigate to favorite screen`() = runTest {\n  val repo = TestFavoritesRepository(Favorite(123L))\n  val presenter = FavoritesPresenter(navigator, repo)\n\n  presenter.test {\n    assertThat(awaitItem()).isEqualTo(FavoritesScreen.State.Loading)\n    val resultsItem = awaitItem() as Results\n    assertThat(resultsItem.favorites).isEqualTo(favorites)\n    val clickFavorite = FavoriteScreen.Event.ClickFavorite(123L)\n\n    // simulate user tapping favorite in UI\n    resultsItem.eventSink(clickFavorite)\n\n    assertThat(navigator.awaitNextScreen()).isEqualTo(FavoriteScreen(clickFavorite.id))\n  }\n}\n</code></pre>"},{"location":"testing/#android-ui-instrumentation-tests","title":"Android UI Instrumentation Tests","text":"<p>UI tests can be driven directly through <code>ComposeTestRule</code> and use its Espresso-esque API for assertions:</p> <p>Here is also a good place to use a <code>TestEventSink</code> and assert expected event emissions from specific UI interactions.</p> <pre><code>@Test\nfun favoritesList_show_favorites_for_result_state() = runTest {\n  val favorites = listOf(Favorite(1L, ...))\n  val events = TestEventSink&lt;FavoriteScreen.Event&gt;()\n\n  composeTestRule.run {\n    setContent { \n      // bootstrap the UI in the desired state\n      FavoritesList(\n        state = FavoriteScreen.State.Results(favorites, events)\n      )\n    }\n\n    onNodeWithTag(\"no favorites\").assertDoesNotExist()\n    onNodeWithText(\"Your Favorites\").assertIsDisplayed()\n    onAllNodesWithTag(\"favorite\").assertCountEquals(1)\n      .get(1)\n      .performClick()\n\n    events.assertEvent(FavoriteScreen.Event.ClickFavorite(1L))\n  }\n}\n</code></pre>"},{"location":"testing/#snapshot-tests","title":"Snapshot Tests","text":"<p>Because Circuit UIs simply take an input state parameter, snapshot tests via Paparazzi or Roborazzi are a breeze.</p> <p>This allows allows you to render UI without a physical device or emulator and assert pixel-perfection on the result.</p> <pre><code>@Test\nfun previewFavorite() {\n  paparazzi.snapshot { PreviewFavorite() }\n}\n</code></pre> <p>These are easy to maintain and review in GitHub.</p> <p>Another neat idea is we think this will make it easy to stand up compose preview functions for IDE use and reuse them.</p> <pre><code>// In your main source\n@Preview\n@Composable\ninternal fun PreviewFavorite() {\n  Favorite()\n}\n\n// In your unit test\n@Test\nfun previewFavorite() {\n  paparazzi.snapshot { PreviewFavorite() }\n}\n</code></pre>"},{"location":"tutorial/","title":"Tutorial","text":"<p>This tutorial will help you ramp up to Circuit with a simple email app.</p> <p>Note this assumes some prior experience with Compose. See these resources for more information:</p> <ul> <li>(Android) Get started with Jetpack Compose</li> <li>(Android) Jetpack Compose Tutorial</li> <li>(Multiplatform) Get started with Compose Multiplatform</li> </ul>"},{"location":"tutorial/#setup","title":"Setup","text":"<p>You can do this tutorial in one of two ways:</p>"},{"location":"tutorial/#1-build-out-of-the-tutorial-sample","title":"1. Build out of the <code>tutorial</code> sample","text":"<p>Clone the circuit repo and work out of the <code>:samples:tutorial</code> module. This has all your dependencies set up and ready to go, along with some reusable common code to save you some boilerplate. You can see an implementation of this tutorial there as well.</p> <p>This can be run on Android or Desktop. - The Desktop entry point is <code>main.kt</code>. To run the main function, you can run <code>./gradlew :samples:tutorial:run</code>. - The Android entry point is <code>MainActivity</code>. Run <code>./gradlew :samples:tutorial:installDebug</code> to install it on a device or emulator.</p>"},{"location":"tutorial/#2-start-from-scratch","title":"2. Start from scratch","text":"<p>First, set up Compose in your project. See the following guides for more information:</p> <ul> <li>Android<ul> <li>Also set up Parcelize</li> </ul> </li> <li>Multiplatform</li> </ul> <p>Next, add the <code>circuit-foundation</code> dependency. This includes all the core Circuit artifacts.</p> build.gradle.kts<pre><code>dependencies {\n  implementation(\"com.slack.circuit:circuit-foundation:&lt;version&gt;\")\n}\n</code></pre> <p>See setup docs for more information.</p>"},{"location":"tutorial/#create-a-screen","title":"Create a <code>Screen</code>","text":"<p>The primary entry points in Circuit are <code>Screen</code>s (docs). These are the navigational building blocks of your app. A <code>Screen</code> is a simple data class or data object that represents a unique location in your app. For example, a <code>Screen</code> could represent an inbox list, an email detail, or a settings screen.</p> <p>Let\u2019s start with a simple <code>Screen</code> that represents an inbox list:</p> AndroidMultiplatform <pre><code>@Parcelize\ndata object InboxScreen : Screen\n</code></pre> <pre><code>data object InboxScreen : Screen\n</code></pre> <p>Tip</p> <p><code>Screen</code> is <code>Parcelable</code> on Android. You should use the Parcelize plugin to annotate your screens with <code>@Parcelize</code>.</p>"},{"location":"tutorial/#design-your-state","title":"Design your state","text":"<p>Next, let\u2019s define some state for our <code>InboxScreen</code>. Circuit uses unidirectional data flow (UDF) to ensure strong separation between presentation logic and UI. States should be stable or immutable, and directly renderable by your UIs. As such, you should design them to be as simple as possible.</p> <p>Conventionally, this is written as a nested <code>State</code> class inside your <code>Screen</code> and must extend <code>CircuitUiState</code> (docs).</p> InboxScreenEmail InboxScreen.kt<pre><code>data object InboxScreen : Screen {\n  data class State(\n    val emails: List&lt;Email&gt;\n  ) : CircuitUiState\n}\n</code></pre> Email.kt<pre><code>@Immutable\ndata class Email(\n  val id: String,\n  val subject: String,\n  val body: String,\n  val sender: String,\n  val timestamp: String,\n  val recipients: List&lt;String&gt;,\n)\n</code></pre> <p>See the states and events guide for more information.</p>"},{"location":"tutorial/#create-your-ui","title":"Create your UI","text":"Inbox <p>Next, let\u2019s define a <code>Ui</code> for our <code>InboxScreen</code>. A <code>Ui</code> is a simple composable function that  takes <code>State</code> and <code>Modifier</code> parameters.</p> <p>It\u2019s responsible for rendering the state. You should write this like a standard composable. In  this case, we\u2019ll use a <code>LazyColumn</code> to render a list of emails.</p> InboxScreen.kt<pre><code>@Composable\nfun Inbox(state: InboxScreen.State, modifier: Modifier = Modifier) {\n  Scaffold(modifier = modifier, topBar = { TopAppBar(title = { Text(\"Inbox\") }) }) { innerPadding -&gt;\n    LazyColumn(modifier = Modifier.padding(innerPadding)) {\n      items(state.emails) { email -&gt;\n        EmailItem(email)\n      }\n    }\n  }\n}\n\n// Write one or use EmailItem from ui.kt\n@Composable\nprivate fun EmailItem(email: Email, modifier: Modifier = Modifier) {\n  // ...\n}\n</code></pre> <p>For more complex UIs with dependencies, you can create a class that implements the <code>Ui</code> interface (docs). This is rarely necessary though, and we won\u2019t use this in the tutorial.</p> InboxUi.kt<pre><code>class InboxUi(...) : Ui&lt;InboxScreen.State&gt; {\n  @Composable\n  override fun Content(state: InboxScreen.State, modifier: Modifier) {\n    LazyColumn(modifier = modifier) {\n      items(state.emails) { email -&gt;\n        EmailItem(email)\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"tutorial/#implement-your-presenter","title":"Implement your presenter","text":"<p>Next, let\u2019s define a <code>Presenter</code> (docs) for our <code>InboxScreen</code>. Circuit presenters are responsible for computing and emitting state.</p> InboxScreen.kt<pre><code>class InboxPresenter : Presenter&lt;InboxScreen.State&gt; {\n  @Composable\n  override fun present(): InboxScreen.State {\n    return InboxScreen.State(\n      emails = listOf(\n        Email(\n          id = \"1\",\n          subject = \"Meeting re-sched!\",\n          body = \"Hey, I'm going to be out of the office tomorrow. Can we reschedule?\",\n          sender = \"Ali Connors\",\n          timestamp = \"3:00 PM\",\n          recipients = listOf(\"all@example.com\"),\n          ),\n        // ... more emails\n      )\n    )\n  }\n}\n</code></pre> <p>This is a trivial implementation that returns a static list of emails. In a real app, you\u2019d likely fetch this data from a repository or other data source. In our tutorial code in the repo, we\u2019ve added a simple <code>EmailRepository</code> that you can use to fetch emails. It exposes a suspending <code>getEmails()</code> function that returns a list of emails.</p> <p>This is also a good opportunity to see where using compose in our presentation logic shines, as we can use Compose\u2019s advanced state management to make our presenter logic more expressive and easy to understand.</p> InboxScreen.kt<pre><code>class InboxPresenter(private val emailRepository: EmailRepository) : Presenter&lt;InboxScreen.State&gt; {\n  @Composable\n  override fun present(): InboxScreen.State {\n    val emails by produceState&lt;List&lt;Email&gt;&gt;(initialValue = emptyList()) {\n      value = emailRepository.getEmails()\n    }\n    // Or a flow!\n    // val emails by emailRepository.getEmailsFlow().collectAsState(initial = emptyList())\n    return InboxScreen.State(emails)\n  }\n}\n</code></pre> <p>Analogous to <code>Ui</code>, you can also define simple/dependency-less presenters as just a top-level function.</p> InboxScreen.kt<pre><code>@Composable\nfun InboxPresenter(): InboxScreen.State {\n  val emails = ...\n  return InboxScreen.State(emails)\n}\n</code></pre> <p>Tip</p> <p>Generally, Circuit presenters are implemented as classes and Circuit UIs are implemented as top-level functions. You can mix and match as needed for a given use case. Under the hood, Circuit will wrap all top-level functions into a class for you.</p>"},{"location":"tutorial/#wiring-it-up","title":"Wiring it up","text":"<p>Now that we have a <code>Screen</code>, <code>State</code>, <code>Ui</code>, and <code>Presenter</code>, let\u2019s wire them up together. Circuit accomplishes this with the <code>Circuit</code> class (docs), which is responsible for connecting screens to their corresponding presenters and UIs. These are created with a simple builder pattern.</p> Creating a Circuit instance<pre><code>val emailRepository = EmailRepository()\nval circuit: Circuit =\n  Circuit.Builder()\n    .addPresenter&lt;InboxScreen, InboxScreen.State&gt;(InboxPresenter(emailRepository))\n    .addUi&lt;InboxScreen, InboxScreen.State&gt; { state, modifier -&gt; Inbox(state, modifier) }\n    .build()\n</code></pre> <p>This instance should usually live on your application\u2019s DI graph.</p> <p>Note</p> <p>This is a simple example that uses the <code>addPresenter</code> and <code>addUi</code> functions. In a real app, you\u2019d likely use a <code>Presenter.Factory</code> and <code>Ui.Factory</code> to create your presenters and UIs dynamically.</p> <p>Once you have this instance, you can plug it into <code>CircuitCompositionLocals</code> (docs) and be on your way. This is usually a one-time setup in your application at its primary entry point.</p> AndroidDesktopJS MainActivity.kt<pre><code>class MainActivity {\n  override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    val circuit = Circuit.Builder()\n      // ...\n      .build()\n\n    setContent {\n      CircuitCompositionLocals(circuit) {\n        // ...\n      }\n    }\n  }\n}\n</code></pre> main.kt<pre><code>fun main() {\n  val circuit = Circuit.Builder()\n    // ...\n    .build()\n\n  application {\n    Window(title = \"Inbox\", onCloseRequest = ::exitApplication) {\n      CircuitCompositionLocals(circuit) {\n        // ...\n      }\n    }\n  }\n}\n</code></pre> main.kt<pre><code>fun main() {\n  val circuit = Circuit.Builder()\n    // ...\n    .build()\n\n  onWasmReady {\n    Window(\"Inbox\") {\n      CircuitCompositionLocals(circuit) {\n        // ...\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"tutorial/#circuitcontent","title":"<code>CircuitContent</code>","text":"<p><code>CircuitContent</code> (docs) is a simple composable that takes a <code>Screen</code> and renders it.</p> CircuitContent<pre><code>CircuitCompositionLocals(circuit) {\n  CircuitContent(InboxScreen)\n}\n</code></pre> <p>Under the hood, this instantiates the corresponding <code>Presenter</code> and <code>Ui</code> from the local <code>Circuit</code> instance and connects them together. All you need to do is pass in the <code>Screen</code> you want to render!</p> <p>This is the most basic way to render a <code>Screen</code>. These can be top-level UIs or nested within other UIs. You can even have multiple <code>CircuitContent</code> instances in the same composition.</p>"},{"location":"tutorial/#adding-navigation-to-our-app","title":"Adding navigation to our app","text":"<p>An app architecture isn\u2019t complete without navigation. Circuit provides a simple navigation API that\u2019s focused around a simple <code>BackStack</code> (docs) that is navigated via a <code>Navigator</code> interface (docs). In most cases, you can use the built-in <code>SaveableBackStack</code> implementation (docs), which is saved and restored in accordance with whatever the platform\u2019s <code>rememberSaveable</code> implementation is.</p> Creating a backstack and navigator<pre><code>val backStack = rememberSaveableBackStack(root = InboxScreen)\nval navigator = rememberCircuitNavigator(backStack) {\n  // Do something when the root screen is popped, usually exiting the app\n}\n</code></pre> <p>Once you have these two components created, you can pass them to an advanced version of <code>CircuitContent</code> that supports navigation called <code>NavigableCircuitContent</code> (docs).</p> NavigableCircuitContent<pre><code>NavigableCircuitContent(navigator = navigator, backstack = backStack)\n</code></pre> <p>This composable will automatically manage the backstack and navigation for you, essentially rendering the \u201ctop\u201d of the back stack as your navigator navigates it. This also handles transitions between screens (<code>NavDecoration</code>) and fallback behavior with <code>Circuit.Builder.onUnavailableRoute</code> (docs).</p> <p>Like with <code>Circuit</code>, this is usually a one-time setup in your application at its primary entry point.</p> Putting it all together<pre><code>val backStack = rememberSaveableBackStack(root = InboxScreen)\nval navigator = rememberCircuitNavigator(backStack) {\n  // Do something when the root screen is popped, usually exiting the app\n}\nCircuitCompositionLocals(circuit) {\n  NavigableCircuitContent(navigator = navigator, backstack = backStack)\n}\n</code></pre>"},{"location":"tutorial/#add-a-detail-screen","title":"Add a detail screen","text":"Detail <p>Now that we have navigation set up, let\u2019s add a detail screen to our app to navigate to.</p> <p>This screen will show the content of a specific email from the inbox, and in a real app would  also show content like the chain history.</p> <p>First, let\u2019s define a <code>DetailScreen</code> and state.</p> AndroidMultiplatform DetailScreen.kt<pre><code>@Parcelize\ndata class DetailScreen(val emailId: String) : Screen {\n  data class State(val email: Email) : CircuitUiState\n}\n</code></pre> DetailScreen.kt<pre><code>data class DetailScreen(val emailId: String) : Screen {\n  data class State(val email: Email) : CircuitUiState\n}\n</code></pre> <p>Notice that this time we use a <code>data class</code> instead of a <code>data object</code>. This is because we want to be able to pass in an <code>emailId</code> to the screen. We\u2019ll use this to fetch the email from our data layer.</p> <p>Warning</p> <p>You should keep <code>Screen</code> parameters as simple as possible and derive any additional data you need from your data layer instead.</p> <p>Next, let\u2019s define a Presenter and UI for this screen.</p> PresenterUI DetailScreen.kt<pre><code>class DetailPresenter(\n  private val screen: DetailScreen,\n  private val emailRepository: EmailRepository\n) : Presenter&lt;DetailScreen.State&gt; {\n  @Composable\n  override fun present(): DetailScreen.State {\n    val email = emailRepository.getEmail(screen.emailId)\n    return DetailScreen.State(email)\n  }\n}\n</code></pre> DetailScreen.kt<pre><code>@Composable\nfun EmailDetail(state: DetailScreen.State, modifier: Modifier = Modifier) {\n  // ...\n  // Write one or use EmailDetailContent from ui.kt\n}\n</code></pre> <p>Note that we\u2019re injecting the <code>DetailScreen</code> into our <code>Presenter</code> so we can get the email ID. This is where Circuit\u2019s factory pattern comes into play. Let\u2019s define a factory for our <code>DetailPresenter</code>.</p> DetailScreen.kt<pre><code>class DetailPresenter(...) : Presenter&lt;DetailScreen.State&gt; {\n  // ...\n  class Factory(private val emailRepository: EmailRepository) : Presenter.Factory {\n    override fun create(screen: Screen, navigator: Navigator, context: CircuitContext): Presenter&lt;*&gt;? {\n      return when (screen) {\n        is DetailScreen -&gt; return DetailPresenter(screen, emailRepository)\n        else -&gt; null\n      }\n    }\n  }\n}\n</code></pre> <p>Here we have access to the screen and dynamically create the presenter we need. It can then pass the screen on to the presenter.</p> <p>We can then wire these detail components to our <code>Circuit</code> instance too.</p> <pre><code>val circuit: Circuit =\n  Circuit.Builder()\n    // ...\n    .addPresenterFactory(DetailPresenter.Factory(emailRepository))\n    .addUi&lt;DetailScreen, DetailScreen.State&gt; { state, modifier -&gt; EmailDetail(state, modifier) }\n    .build()\n</code></pre>"},{"location":"tutorial/#navigate-to-the-detail-screen","title":"Navigate to the detail screen","text":"<p>Now that we have a detail screen, let\u2019s navigate to it from our inbox list. As you can see in our presenter factory above, Circuit also offers access to a <code>Navigator</code> in this <code>create()</code> call that factories can then pass on to their created presenters. </p> <p>Let\u2019s add a <code>Navigator</code> property to our presenter and create a factory for our inbox screen now.</p> InboxPresenterCircuit instance InboxScreen.kt<pre><code>class InboxPresenter(\n  private val navigator: Navigator,\n  private val emailRepository: EmailRepository\n) : Presenter&lt;InboxScreen.State&gt; {\n  // ...\n  class Factory(private val emailRepository: EmailRepository) : Presenter.Factory {\n    override fun create(screen: Screen, navigator: Navigator, context: CircuitContext): Presenter&lt;*&gt;? {\n      return when (screen) {\n        InboxScreen -&gt; return InboxPresenter(navigator, emailRepository)\n        else -&gt; null\n      }\n    }\n  }\n}\n</code></pre> <pre><code>val circuit: Circuit =\n  Circuit.Builder()\n    .addPresenterFactory(InboxPresenter.Factory(emailRepository))\n    .addUi&lt;InboxScreen, InboxScreen.State&gt; { state, modifier -&gt; Inbox(state, modifier) }\n    .addPresenterFactory(DetailPresenter.Factory(emailRepository))\n    .addUi&lt;DetailScreen, DetailScreen.State&gt; { state, modifier -&gt; EmailDetail(state, modifier) }\n    .build()\n</code></pre> <p>Now that we have a <code>Navigator</code> in our inbox presenter, we can use it to navigate to the detail screen. First, we need to explore how events work in Circuit.</p>"},{"location":"tutorial/#events","title":"Events","text":"<p>So far, we\u2019ve covered state. State is produced by the presenter and consumed by the UI. That\u2019s only half of the UDF picture though! Events are the inverse: they\u2019re produced by the UI and consumed by the presenter. Events are how you can trigger actions in your app, such as navigation. This completes the circuit.</p> <p>Events in Circuit are a little unconventional in that Circuit doesn\u2019t provide structured APIs for pipelining events from the UI to presenters. Instead, we use an event sink property pattern, where states contain a trailing <code>eventSink</code> function that receives events emitted from the UI.</p> <p>This provides many benefits, see the events guide for more information.</p> <p>Let\u2019s add an event to our inbox screen for when the user clicks on an email.</p> <p>Events must implement <code>CircuitUiEvent</code> (docs) and are usually modeled as a <code>sealed interface</code> hierarchy, where each subtype is a different event type.</p> InboxScreen.kt<pre><code>data object InboxScreen : Screen {\n  data class State(\n    val emails: List&lt;Email&gt;,\n    val eventSink: (Event) -&gt; Unit\n  ) : CircuitUiState\n  sealed class Event : CircuitUiEvent {\n    data class EmailClicked(val emailId: String) : Event()\n  }\n}\n</code></pre> <p>Now that we have an event, let\u2019s emit it from our UI.</p> InboxScreen.kt<pre><code>@Composable\nfun Inbox(state: InboxScreen.State, modifier: Modifier = Modifier) {\n  Scaffold(modifier = modifier, topBar = { TopAppBar(title = { Text(\"Inbox\") }) }) { innerPadding -&gt;\n    LazyColumn(modifier = Modifier.padding(innerPadding)) {\n      items(state.emails) { email -&gt;\n        EmailItem(\n          email = email,\n          onClick = { state.eventSink(InboxScreen.Event.EmailClicked(email.id)) },\n        )\n      }\n    }\n  }\n}\n\n// Write one or use EmailItem from ui.kt\nprivate fun EmailItem(email: Email, modifier: Modifier = Modifier, onClick: () -&gt; Unit) {\n  // ...\n}\n</code></pre> <p>Finally, let\u2019s handle this event in our presenter.</p> InboxScreen.kt<pre><code>class InboxPresenter(\n  private val navigator: Navigator,\n  private val emailRepository: EmailRepository\n) : Presenter&lt;InboxScreen.State&gt; {\n  @Composable\n  override fun present(): InboxScreen.State {\n    // ...\n    return InboxScreen.State(emails) { event -&gt;\n      when (event) {\n        // Navigate to the detail screen when an email is clicked\n        is EmailClicked -&gt; navigator.goTo(DetailScreen(event.emailId))\n      }\n    }\n  }\n}\n</code></pre> <p>This demonstrates how we can navigate forward in our app and pass data with it. Let\u2019s see how we can navigate back.</p>"},{"location":"tutorial/#navigating-back","title":"Navigating back","text":"<p>Naturally, navigation can\u2019t be just one way. The opposite of <code>Navigator.goTo()</code> is <code>Navigator.pop()</code>, which pops the back stack back to the previous screen. To use this, let\u2019s add a back button to our detail screen and wire it up to a <code>Navigator</code>.</p> DetailScreenDetailContentDetailPresenter DetailScreen.kt<pre><code>data class DetailScreen(val emailId: String) : Screen {\n  data class State(\n    val email: Email,\n    val eventSink: (Event) -&gt; Unit\n  ) : CircuitUiState\n  sealed class Event : CircuitUiEvent {\n    data object BackClicked : Event()\n  }\n}\n</code></pre> DetailScreen.kt<pre><code>@Composable\nfun EmailDetail(state: DetailScreen.State, modifier: Modifier = Modifier) {\n  Scaffold(\n    modifier = modifier,\n    topBar = {\n      TopAppBar(\n        title = { Text(state.email.subject) },\n        navigationIcon = {\n          IconButton(onClick = { state.eventSink(DetailScreen.Event.BackClicked) }) {\n            Icon(Icons.Default.ArrowBack, contentDescription = \"Back\")\n          }\n        },\n      )\n    },\n  ) { innerPadding -&gt;\n    // Remaining detail UI...\n  }\n}\n</code></pre> DetailScreen.kt<pre><code>class DetailPresenter(\n  private val screen: DetailScreen,\n  private val navigator: Navigator,\n  private val emailRepository: EmailRepository,\n) : Presenter&lt;DetailScreen.State&gt; {\n  @Composable\n  override fun present(): DetailScreen.State {\n    // ...\n    return DetailScreen.State(email) { event -&gt;\n      when (event) {\n        DetailScreen.Event.BackClicked -&gt; navigator.pop()\n      }\n    }\n  }\n  // ...\n}\n</code></pre> <p>On Android, <code>NavigableCircuitContent</code> automatically hooks into BackHandler to automatically pop on system back presses. On Desktop, it\u2019s recommended to wire the ESC key.</p>"},{"location":"tutorial/#conclusion","title":"Conclusion","text":"<p>This is just a brief introduction to Circuit. For more information see various docs on the site, samples in the repo, the API reference, and check out other Circuit tools like circuit-retained, CircuitX, factory code gen, overlays, navigation with results, testing, multiplatform, and more.</p>"},{"location":"ui/","title":"UI","text":"<p>The core Ui interface is simply this:</p> <pre><code>interface Ui&lt;UiState : CircuitUiState&gt; {\n  @Composable fun Content(state: UiState, modifier: Modifier)\n}\n</code></pre> <p>Like presenters, simple UIs can also skip the class all together for use in other UIs. Core unit of granularity is just the @Composable function. In fact, when implementing these in practice they rarely use dependency injection at all and can normally just be written as top-level composable functions annotated with<code>@CircuitInject</code>.</p> <pre><code>@CircuitInject&lt;FavoritesScreen&gt; // Relevant DI wiring is generated\n@Composable\nprivate fun Favorites(state: FavoritesState, modifier: Modifier = Modifier) {\n  // ...\n}\n</code></pre> <p>Writing UIs like this has a number of benefits.</p> <ul> <li>Functions-only nudges developers toward writing idiomatic compose code and not keeping un-scoped/un-observable state elsewhere (such as class properties).</li> <li>These functions are extremely easy to stand up in tests.</li> <li>These functions are extremely easy to stand up in Compose preview functions.</li> </ul> <p>Let\u2019s look a little more closely at the last bullet point about preview functions. With the above example, we can easily stand up previews for all of our different states!</p> <pre><code>@Preview\n@Composable\nprivate fun PreviewFavorites() = Favorites(FavoritesState(listOf(\"Reeses\", \"Lola\")))\n\n@Preview\n@Composable\nprivate fun PreviewEmptyFavorites() = Favorites(FavoritesState(listOf()))\n</code></pre>"},{"location":"ui/#static-ui","title":"Static UI","text":"<p>In some cases, a UI may not need a presenter to compute or manage its state. Examples of this include UIs that are stateless or can derive their state from a single static input or an input [Screen]\u2019s properties. In these cases, make your screen implement the <code>StaticScreen</code> interface. When a <code>StaticScreen</code> is used, Circuit will internally allow the UI to run on its own and won\u2019t connect it to a presenter if no presenter is provided.</p>"}]}